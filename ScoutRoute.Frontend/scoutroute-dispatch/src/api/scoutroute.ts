/**
 * Generated by orval v7.9.0 üç∫
 * Do not edit manually.
 * ScoutRoute.ApiService | v1
 * OpenAPI spec version: 1.0.0
 */
import { useMutation, useQuery } from "@tanstack/react-query";
import type {
  DataTag,
  DefinedInitialDataOptions,
  DefinedUseQueryResult,
  MutationFunction,
  QueryClient,
  QueryFunction,
  QueryKey,
  UndefinedInitialDataOptions,
  UseMutationOptions,
  UseMutationResult,
  UseQueryOptions,
  UseQueryResult,
} from "@tanstack/react-query";

import * as axios from "axios";
import type { AxiosError, AxiosRequestConfig, AxiosResponse } from "axios";

import type {
  AddCommentCommand,
  AddStopCommand,
  AddTeamMemberCommand,
  AssignAddressCommand,
  AssignTeamCommand,
  CreateProjectCommand,
  CreateRouteCommand,
  CreateStopCommand,
  CreateTeamCommand,
  ListTeamDto,
  PaymentDto,
  ProblemDetails,
  ProjectDto,
  ProjectQueryResult,
  RegisterPaymentCommand,
  RouteDto,
  StopDto,
  TeamDto,
  UpdateProjectCommand,
  UpdateRouteCommand,
  UpdateTeamLeadCommand,
  UpdateTeamNameCommand,
  UpdateTeamPhoneCommand,
  UpdateTeamTrailerTypeCommand,
} from "../models";

export const assignAddress = (
  paymentId: string,
  assignAddressCommand: AssignAddressCommand,
  options?: AxiosRequestConfig,
): Promise<AxiosResponse<void>> => {
  return axios.default.put(
    `https://localhost:7520/payments/${paymentId}/address`,
    assignAddressCommand,
    options,
  );
};

export const getAssignAddressMutationOptions = <
  TError = AxiosError<unknown>,
  TContext = unknown,
>(options?: {
  mutation?: UseMutationOptions<
    Awaited<ReturnType<typeof assignAddress>>,
    TError,
    { paymentId: string; data: AssignAddressCommand },
    TContext
  >;
  axios?: AxiosRequestConfig;
}): UseMutationOptions<
  Awaited<ReturnType<typeof assignAddress>>,
  TError,
  { paymentId: string; data: AssignAddressCommand },
  TContext
> => {
  const mutationKey = ["assignAddress"];
  const { mutation: mutationOptions, axios: axiosOptions } = options
    ? options.mutation &&
      "mutationKey" in options.mutation &&
      options.mutation.mutationKey
      ? options
      : { ...options, mutation: { ...options.mutation, mutationKey } }
    : { mutation: { mutationKey }, axios: undefined };

  const mutationFn: MutationFunction<
    Awaited<ReturnType<typeof assignAddress>>,
    { paymentId: string; data: AssignAddressCommand }
  > = (props) => {
    const { paymentId, data } = props ?? {};

    return assignAddress(paymentId, data, axiosOptions);
  };

  return { mutationFn, ...mutationOptions };
};

export type AssignAddressMutationResult = NonNullable<
  Awaited<ReturnType<typeof assignAddress>>
>;
export type AssignAddressMutationBody = AssignAddressCommand;
export type AssignAddressMutationError = AxiosError<unknown>;

export const useAssignAddress = <
  TError = AxiosError<unknown>,
  TContext = unknown,
>(
  options?: {
    mutation?: UseMutationOptions<
      Awaited<ReturnType<typeof assignAddress>>,
      TError,
      { paymentId: string; data: AssignAddressCommand },
      TContext
    >;
    axios?: AxiosRequestConfig;
  },
  queryClient?: QueryClient,
): UseMutationResult<
  Awaited<ReturnType<typeof assignAddress>>,
  TError,
  { paymentId: string; data: AssignAddressCommand },
  TContext
> => {
  const mutationOptions = getAssignAddressMutationOptions(options);

  return useMutation(mutationOptions, queryClient);
};

export const registerPayment = (
  registerPaymentCommand: RegisterPaymentCommand,
  options?: AxiosRequestConfig,
): Promise<AxiosResponse<void>> => {
  return axios.default.post(
    `https://localhost:7520/payments`,
    registerPaymentCommand,
    options,
  );
};

export const getRegisterPaymentMutationOptions = <
  TError = AxiosError<unknown>,
  TContext = unknown,
>(options?: {
  mutation?: UseMutationOptions<
    Awaited<ReturnType<typeof registerPayment>>,
    TError,
    { data: RegisterPaymentCommand },
    TContext
  >;
  axios?: AxiosRequestConfig;
}): UseMutationOptions<
  Awaited<ReturnType<typeof registerPayment>>,
  TError,
  { data: RegisterPaymentCommand },
  TContext
> => {
  const mutationKey = ["registerPayment"];
  const { mutation: mutationOptions, axios: axiosOptions } = options
    ? options.mutation &&
      "mutationKey" in options.mutation &&
      options.mutation.mutationKey
      ? options
      : { ...options, mutation: { ...options.mutation, mutationKey } }
    : { mutation: { mutationKey }, axios: undefined };

  const mutationFn: MutationFunction<
    Awaited<ReturnType<typeof registerPayment>>,
    { data: RegisterPaymentCommand }
  > = (props) => {
    const { data } = props ?? {};

    return registerPayment(data, axiosOptions);
  };

  return { mutationFn, ...mutationOptions };
};

export type RegisterPaymentMutationResult = NonNullable<
  Awaited<ReturnType<typeof registerPayment>>
>;
export type RegisterPaymentMutationBody = RegisterPaymentCommand;
export type RegisterPaymentMutationError = AxiosError<unknown>;

export const useRegisterPayment = <
  TError = AxiosError<unknown>,
  TContext = unknown,
>(
  options?: {
    mutation?: UseMutationOptions<
      Awaited<ReturnType<typeof registerPayment>>,
      TError,
      { data: RegisterPaymentCommand },
      TContext
    >;
    axios?: AxiosRequestConfig;
  },
  queryClient?: QueryClient,
): UseMutationResult<
  Awaited<ReturnType<typeof registerPayment>>,
  TError,
  { data: RegisterPaymentCommand },
  TContext
> => {
  const mutationOptions = getRegisterPaymentMutationOptions(options);

  return useMutation(mutationOptions, queryClient);
};

export const completePayment = (
  paymentId: string,
  options?: AxiosRequestConfig,
): Promise<AxiosResponse<void>> => {
  return axios.default.put(
    `https://localhost:7520/payments/${paymentId}/completed`,
    undefined,
    options,
  );
};

export const getCompletePaymentMutationOptions = <
  TError = AxiosError<unknown>,
  TContext = unknown,
>(options?: {
  mutation?: UseMutationOptions<
    Awaited<ReturnType<typeof completePayment>>,
    TError,
    { paymentId: string },
    TContext
  >;
  axios?: AxiosRequestConfig;
}): UseMutationOptions<
  Awaited<ReturnType<typeof completePayment>>,
  TError,
  { paymentId: string },
  TContext
> => {
  const mutationKey = ["completePayment"];
  const { mutation: mutationOptions, axios: axiosOptions } = options
    ? options.mutation &&
      "mutationKey" in options.mutation &&
      options.mutation.mutationKey
      ? options
      : { ...options, mutation: { ...options.mutation, mutationKey } }
    : { mutation: { mutationKey }, axios: undefined };

  const mutationFn: MutationFunction<
    Awaited<ReturnType<typeof completePayment>>,
    { paymentId: string }
  > = (props) => {
    const { paymentId } = props ?? {};

    return completePayment(paymentId, axiosOptions);
  };

  return { mutationFn, ...mutationOptions };
};

export type CompletePaymentMutationResult = NonNullable<
  Awaited<ReturnType<typeof completePayment>>
>;

export type CompletePaymentMutationError = AxiosError<unknown>;

export const useCompletePayment = <
  TError = AxiosError<unknown>,
  TContext = unknown,
>(
  options?: {
    mutation?: UseMutationOptions<
      Awaited<ReturnType<typeof completePayment>>,
      TError,
      { paymentId: string },
      TContext
    >;
    axios?: AxiosRequestConfig;
  },
  queryClient?: QueryClient,
): UseMutationResult<
  Awaited<ReturnType<typeof completePayment>>,
  TError,
  { paymentId: string },
  TContext
> => {
  const mutationOptions = getCompletePaymentMutationOptions(options);

  return useMutation(mutationOptions, queryClient);
};

export const getIncompletePayments = (
  options?: AxiosRequestConfig,
): Promise<AxiosResponse<PaymentDto[]>> => {
  return axios.default.get(
    `https://localhost:7520/payments/incomplete`,
    options,
  );
};

export const getGetIncompletePaymentsQueryKey = () => {
  return [`https://localhost:7520/payments/incomplete`] as const;
};

export const getGetIncompletePaymentsQueryOptions = <
  TData = Awaited<ReturnType<typeof getIncompletePayments>>,
  TError = AxiosError<unknown>,
>(options?: {
  query?: Partial<
    UseQueryOptions<
      Awaited<ReturnType<typeof getIncompletePayments>>,
      TError,
      TData
    >
  >;
  axios?: AxiosRequestConfig;
}) => {
  const { query: queryOptions, axios: axiosOptions } = options ?? {};

  const queryKey = queryOptions?.queryKey ?? getGetIncompletePaymentsQueryKey();

  const queryFn: QueryFunction<
    Awaited<ReturnType<typeof getIncompletePayments>>
  > = ({ signal }) => getIncompletePayments({ signal, ...axiosOptions });

  return { queryKey, queryFn, ...queryOptions } as UseQueryOptions<
    Awaited<ReturnType<typeof getIncompletePayments>>,
    TError,
    TData
  > & { queryKey: DataTag<QueryKey, TData, TError> };
};

export type GetIncompletePaymentsQueryResult = NonNullable<
  Awaited<ReturnType<typeof getIncompletePayments>>
>;
export type GetIncompletePaymentsQueryError = AxiosError<unknown>;

export function useGetIncompletePayments<
  TData = Awaited<ReturnType<typeof getIncompletePayments>>,
  TError = AxiosError<unknown>,
>(
  options: {
    query: Partial<
      UseQueryOptions<
        Awaited<ReturnType<typeof getIncompletePayments>>,
        TError,
        TData
      >
    > &
      Pick<
        DefinedInitialDataOptions<
          Awaited<ReturnType<typeof getIncompletePayments>>,
          TError,
          Awaited<ReturnType<typeof getIncompletePayments>>
        >,
        "initialData"
      >;
    axios?: AxiosRequestConfig;
  },
  queryClient?: QueryClient,
): DefinedUseQueryResult<TData, TError> & {
  queryKey: DataTag<QueryKey, TData, TError>;
};
export function useGetIncompletePayments<
  TData = Awaited<ReturnType<typeof getIncompletePayments>>,
  TError = AxiosError<unknown>,
>(
  options?: {
    query?: Partial<
      UseQueryOptions<
        Awaited<ReturnType<typeof getIncompletePayments>>,
        TError,
        TData
      >
    > &
      Pick<
        UndefinedInitialDataOptions<
          Awaited<ReturnType<typeof getIncompletePayments>>,
          TError,
          Awaited<ReturnType<typeof getIncompletePayments>>
        >,
        "initialData"
      >;
    axios?: AxiosRequestConfig;
  },
  queryClient?: QueryClient,
): UseQueryResult<TData, TError> & {
  queryKey: DataTag<QueryKey, TData, TError>;
};
export function useGetIncompletePayments<
  TData = Awaited<ReturnType<typeof getIncompletePayments>>,
  TError = AxiosError<unknown>,
>(
  options?: {
    query?: Partial<
      UseQueryOptions<
        Awaited<ReturnType<typeof getIncompletePayments>>,
        TError,
        TData
      >
    >;
    axios?: AxiosRequestConfig;
  },
  queryClient?: QueryClient,
): UseQueryResult<TData, TError> & {
  queryKey: DataTag<QueryKey, TData, TError>;
};

export function useGetIncompletePayments<
  TData = Awaited<ReturnType<typeof getIncompletePayments>>,
  TError = AxiosError<unknown>,
>(
  options?: {
    query?: Partial<
      UseQueryOptions<
        Awaited<ReturnType<typeof getIncompletePayments>>,
        TError,
        TData
      >
    >;
    axios?: AxiosRequestConfig;
  },
  queryClient?: QueryClient,
): UseQueryResult<TData, TError> & {
  queryKey: DataTag<QueryKey, TData, TError>;
} {
  const queryOptions = getGetIncompletePaymentsQueryOptions(options);

  const query = useQuery(queryOptions, queryClient) as UseQueryResult<
    TData,
    TError
  > & { queryKey: DataTag<QueryKey, TData, TError> };

  query.queryKey = queryOptions.queryKey;

  return query;
}

export const createProject = (
  createProjectCommand: CreateProjectCommand,
  options?: AxiosRequestConfig,
): Promise<AxiosResponse<void>> => {
  return axios.default.post(
    `https://localhost:7520/projects`,
    createProjectCommand,
    options,
  );
};

export const getCreateProjectMutationOptions = <
  TError = AxiosError<ProblemDetails>,
  TContext = unknown,
>(options?: {
  mutation?: UseMutationOptions<
    Awaited<ReturnType<typeof createProject>>,
    TError,
    { data: CreateProjectCommand },
    TContext
  >;
  axios?: AxiosRequestConfig;
}): UseMutationOptions<
  Awaited<ReturnType<typeof createProject>>,
  TError,
  { data: CreateProjectCommand },
  TContext
> => {
  const mutationKey = ["createProject"];
  const { mutation: mutationOptions, axios: axiosOptions } = options
    ? options.mutation &&
      "mutationKey" in options.mutation &&
      options.mutation.mutationKey
      ? options
      : { ...options, mutation: { ...options.mutation, mutationKey } }
    : { mutation: { mutationKey }, axios: undefined };

  const mutationFn: MutationFunction<
    Awaited<ReturnType<typeof createProject>>,
    { data: CreateProjectCommand }
  > = (props) => {
    const { data } = props ?? {};

    return createProject(data, axiosOptions);
  };

  return { mutationFn, ...mutationOptions };
};

export type CreateProjectMutationResult = NonNullable<
  Awaited<ReturnType<typeof createProject>>
>;
export type CreateProjectMutationBody = CreateProjectCommand;
export type CreateProjectMutationError = AxiosError<ProblemDetails>;

export const useCreateProject = <
  TError = AxiosError<ProblemDetails>,
  TContext = unknown,
>(
  options?: {
    mutation?: UseMutationOptions<
      Awaited<ReturnType<typeof createProject>>,
      TError,
      { data: CreateProjectCommand },
      TContext
    >;
    axios?: AxiosRequestConfig;
  },
  queryClient?: QueryClient,
): UseMutationResult<
  Awaited<ReturnType<typeof createProject>>,
  TError,
  { data: CreateProjectCommand },
  TContext
> => {
  const mutationOptions = getCreateProjectMutationOptions(options);

  return useMutation(mutationOptions, queryClient);
};

export const getAllProjects = (
  options?: AxiosRequestConfig,
): Promise<AxiosResponse<ProjectQueryResult>> => {
  return axios.default.get(`https://localhost:7520/projects`, options);
};

export const getGetAllProjectsQueryKey = () => {
  return [`https://localhost:7520/projects`] as const;
};

export const getGetAllProjectsQueryOptions = <
  TData = Awaited<ReturnType<typeof getAllProjects>>,
  TError = AxiosError<unknown>,
>(options?: {
  query?: Partial<
    UseQueryOptions<Awaited<ReturnType<typeof getAllProjects>>, TError, TData>
  >;
  axios?: AxiosRequestConfig;
}) => {
  const { query: queryOptions, axios: axiosOptions } = options ?? {};

  const queryKey = queryOptions?.queryKey ?? getGetAllProjectsQueryKey();

  const queryFn: QueryFunction<Awaited<ReturnType<typeof getAllProjects>>> = ({
    signal,
  }) => getAllProjects({ signal, ...axiosOptions });

  return { queryKey, queryFn, ...queryOptions } as UseQueryOptions<
    Awaited<ReturnType<typeof getAllProjects>>,
    TError,
    TData
  > & { queryKey: DataTag<QueryKey, TData, TError> };
};

export type GetAllProjectsQueryResult = NonNullable<
  Awaited<ReturnType<typeof getAllProjects>>
>;
export type GetAllProjectsQueryError = AxiosError<unknown>;

export function useGetAllProjects<
  TData = Awaited<ReturnType<typeof getAllProjects>>,
  TError = AxiosError<unknown>,
>(
  options: {
    query: Partial<
      UseQueryOptions<Awaited<ReturnType<typeof getAllProjects>>, TError, TData>
    > &
      Pick<
        DefinedInitialDataOptions<
          Awaited<ReturnType<typeof getAllProjects>>,
          TError,
          Awaited<ReturnType<typeof getAllProjects>>
        >,
        "initialData"
      >;
    axios?: AxiosRequestConfig;
  },
  queryClient?: QueryClient,
): DefinedUseQueryResult<TData, TError> & {
  queryKey: DataTag<QueryKey, TData, TError>;
};
export function useGetAllProjects<
  TData = Awaited<ReturnType<typeof getAllProjects>>,
  TError = AxiosError<unknown>,
>(
  options?: {
    query?: Partial<
      UseQueryOptions<Awaited<ReturnType<typeof getAllProjects>>, TError, TData>
    > &
      Pick<
        UndefinedInitialDataOptions<
          Awaited<ReturnType<typeof getAllProjects>>,
          TError,
          Awaited<ReturnType<typeof getAllProjects>>
        >,
        "initialData"
      >;
    axios?: AxiosRequestConfig;
  },
  queryClient?: QueryClient,
): UseQueryResult<TData, TError> & {
  queryKey: DataTag<QueryKey, TData, TError>;
};
export function useGetAllProjects<
  TData = Awaited<ReturnType<typeof getAllProjects>>,
  TError = AxiosError<unknown>,
>(
  options?: {
    query?: Partial<
      UseQueryOptions<Awaited<ReturnType<typeof getAllProjects>>, TError, TData>
    >;
    axios?: AxiosRequestConfig;
  },
  queryClient?: QueryClient,
): UseQueryResult<TData, TError> & {
  queryKey: DataTag<QueryKey, TData, TError>;
};

export function useGetAllProjects<
  TData = Awaited<ReturnType<typeof getAllProjects>>,
  TError = AxiosError<unknown>,
>(
  options?: {
    query?: Partial<
      UseQueryOptions<Awaited<ReturnType<typeof getAllProjects>>, TError, TData>
    >;
    axios?: AxiosRequestConfig;
  },
  queryClient?: QueryClient,
): UseQueryResult<TData, TError> & {
  queryKey: DataTag<QueryKey, TData, TError>;
} {
  const queryOptions = getGetAllProjectsQueryOptions(options);

  const query = useQuery(queryOptions, queryClient) as UseQueryResult<
    TData,
    TError
  > & { queryKey: DataTag<QueryKey, TData, TError> };

  query.queryKey = queryOptions.queryKey;

  return query;
}

export const updateProject = (
  projectId: string,
  updateProjectCommand: UpdateProjectCommand,
  options?: AxiosRequestConfig,
): Promise<AxiosResponse<void>> => {
  return axios.default.put(
    `https://localhost:7520/projects/${projectId}`,
    updateProjectCommand,
    options,
  );
};

export const getUpdateProjectMutationOptions = <
  TError = AxiosError<ProblemDetails>,
  TContext = unknown,
>(options?: {
  mutation?: UseMutationOptions<
    Awaited<ReturnType<typeof updateProject>>,
    TError,
    { projectId: string; data: UpdateProjectCommand },
    TContext
  >;
  axios?: AxiosRequestConfig;
}): UseMutationOptions<
  Awaited<ReturnType<typeof updateProject>>,
  TError,
  { projectId: string; data: UpdateProjectCommand },
  TContext
> => {
  const mutationKey = ["updateProject"];
  const { mutation: mutationOptions, axios: axiosOptions } = options
    ? options.mutation &&
      "mutationKey" in options.mutation &&
      options.mutation.mutationKey
      ? options
      : { ...options, mutation: { ...options.mutation, mutationKey } }
    : { mutation: { mutationKey }, axios: undefined };

  const mutationFn: MutationFunction<
    Awaited<ReturnType<typeof updateProject>>,
    { projectId: string; data: UpdateProjectCommand }
  > = (props) => {
    const { projectId, data } = props ?? {};

    return updateProject(projectId, data, axiosOptions);
  };

  return { mutationFn, ...mutationOptions };
};

export type UpdateProjectMutationResult = NonNullable<
  Awaited<ReturnType<typeof updateProject>>
>;
export type UpdateProjectMutationBody = UpdateProjectCommand;
export type UpdateProjectMutationError = AxiosError<ProblemDetails>;

export const useUpdateProject = <
  TError = AxiosError<ProblemDetails>,
  TContext = unknown,
>(
  options?: {
    mutation?: UseMutationOptions<
      Awaited<ReturnType<typeof updateProject>>,
      TError,
      { projectId: string; data: UpdateProjectCommand },
      TContext
    >;
    axios?: AxiosRequestConfig;
  },
  queryClient?: QueryClient,
): UseMutationResult<
  Awaited<ReturnType<typeof updateProject>>,
  TError,
  { projectId: string; data: UpdateProjectCommand },
  TContext
> => {
  const mutationOptions = getUpdateProjectMutationOptions(options);

  return useMutation(mutationOptions, queryClient);
};

export const deleteProject = (
  projectId: string,
  options?: AxiosRequestConfig,
): Promise<AxiosResponse<void>> => {
  return axios.default.delete(
    `https://localhost:7520/projects/${projectId}`,
    options,
  );
};

export const getDeleteProjectMutationOptions = <
  TError = AxiosError<unknown>,
  TContext = unknown,
>(options?: {
  mutation?: UseMutationOptions<
    Awaited<ReturnType<typeof deleteProject>>,
    TError,
    { projectId: string },
    TContext
  >;
  axios?: AxiosRequestConfig;
}): UseMutationOptions<
  Awaited<ReturnType<typeof deleteProject>>,
  TError,
  { projectId: string },
  TContext
> => {
  const mutationKey = ["deleteProject"];
  const { mutation: mutationOptions, axios: axiosOptions } = options
    ? options.mutation &&
      "mutationKey" in options.mutation &&
      options.mutation.mutationKey
      ? options
      : { ...options, mutation: { ...options.mutation, mutationKey } }
    : { mutation: { mutationKey }, axios: undefined };

  const mutationFn: MutationFunction<
    Awaited<ReturnType<typeof deleteProject>>,
    { projectId: string }
  > = (props) => {
    const { projectId } = props ?? {};

    return deleteProject(projectId, axiosOptions);
  };

  return { mutationFn, ...mutationOptions };
};

export type DeleteProjectMutationResult = NonNullable<
  Awaited<ReturnType<typeof deleteProject>>
>;

export type DeleteProjectMutationError = AxiosError<unknown>;

export const useDeleteProject = <
  TError = AxiosError<unknown>,
  TContext = unknown,
>(
  options?: {
    mutation?: UseMutationOptions<
      Awaited<ReturnType<typeof deleteProject>>,
      TError,
      { projectId: string },
      TContext
    >;
    axios?: AxiosRequestConfig;
  },
  queryClient?: QueryClient,
): UseMutationResult<
  Awaited<ReturnType<typeof deleteProject>>,
  TError,
  { projectId: string },
  TContext
> => {
  const mutationOptions = getDeleteProjectMutationOptions(options);

  return useMutation(mutationOptions, queryClient);
};

export const getProject = (
  projectId: string,
  options?: AxiosRequestConfig,
): Promise<AxiosResponse<ProjectDto>> => {
  return axios.default.get(
    `https://localhost:7520/projects/${projectId}`,
    options,
  );
};

export const getGetProjectQueryKey = (projectId: string) => {
  return [`https://localhost:7520/projects/${projectId}`] as const;
};

export const getGetProjectQueryOptions = <
  TData = Awaited<ReturnType<typeof getProject>>,
  TError = AxiosError<unknown>,
>(
  projectId: string,
  options?: {
    query?: Partial<
      UseQueryOptions<Awaited<ReturnType<typeof getProject>>, TError, TData>
    >;
    axios?: AxiosRequestConfig;
  },
) => {
  const { query: queryOptions, axios: axiosOptions } = options ?? {};

  const queryKey = queryOptions?.queryKey ?? getGetProjectQueryKey(projectId);

  const queryFn: QueryFunction<Awaited<ReturnType<typeof getProject>>> = ({
    signal,
  }) => getProject(projectId, { signal, ...axiosOptions });

  return {
    queryKey,
    queryFn,
    enabled: !!projectId,
    ...queryOptions,
  } as UseQueryOptions<
    Awaited<ReturnType<typeof getProject>>,
    TError,
    TData
  > & { queryKey: DataTag<QueryKey, TData, TError> };
};

export type GetProjectQueryResult = NonNullable<
  Awaited<ReturnType<typeof getProject>>
>;
export type GetProjectQueryError = AxiosError<unknown>;

export function useGetProject<
  TData = Awaited<ReturnType<typeof getProject>>,
  TError = AxiosError<unknown>,
>(
  projectId: string,
  options: {
    query: Partial<
      UseQueryOptions<Awaited<ReturnType<typeof getProject>>, TError, TData>
    > &
      Pick<
        DefinedInitialDataOptions<
          Awaited<ReturnType<typeof getProject>>,
          TError,
          Awaited<ReturnType<typeof getProject>>
        >,
        "initialData"
      >;
    axios?: AxiosRequestConfig;
  },
  queryClient?: QueryClient,
): DefinedUseQueryResult<TData, TError> & {
  queryKey: DataTag<QueryKey, TData, TError>;
};
export function useGetProject<
  TData = Awaited<ReturnType<typeof getProject>>,
  TError = AxiosError<unknown>,
>(
  projectId: string,
  options?: {
    query?: Partial<
      UseQueryOptions<Awaited<ReturnType<typeof getProject>>, TError, TData>
    > &
      Pick<
        UndefinedInitialDataOptions<
          Awaited<ReturnType<typeof getProject>>,
          TError,
          Awaited<ReturnType<typeof getProject>>
        >,
        "initialData"
      >;
    axios?: AxiosRequestConfig;
  },
  queryClient?: QueryClient,
): UseQueryResult<TData, TError> & {
  queryKey: DataTag<QueryKey, TData, TError>;
};
export function useGetProject<
  TData = Awaited<ReturnType<typeof getProject>>,
  TError = AxiosError<unknown>,
>(
  projectId: string,
  options?: {
    query?: Partial<
      UseQueryOptions<Awaited<ReturnType<typeof getProject>>, TError, TData>
    >;
    axios?: AxiosRequestConfig;
  },
  queryClient?: QueryClient,
): UseQueryResult<TData, TError> & {
  queryKey: DataTag<QueryKey, TData, TError>;
};

export function useGetProject<
  TData = Awaited<ReturnType<typeof getProject>>,
  TError = AxiosError<unknown>,
>(
  projectId: string,
  options?: {
    query?: Partial<
      UseQueryOptions<Awaited<ReturnType<typeof getProject>>, TError, TData>
    >;
    axios?: AxiosRequestConfig;
  },
  queryClient?: QueryClient,
): UseQueryResult<TData, TError> & {
  queryKey: DataTag<QueryKey, TData, TError>;
} {
  const queryOptions = getGetProjectQueryOptions(projectId, options);

  const query = useQuery(queryOptions, queryClient) as UseQueryResult<
    TData,
    TError
  > & { queryKey: DataTag<QueryKey, TData, TError> };

  query.queryKey = queryOptions.queryKey;

  return query;
}

export const createRoute = (
  projectId: string,
  createRouteCommand: CreateRouteCommand,
  options?: AxiosRequestConfig,
): Promise<AxiosResponse<void>> => {
  return axios.default.post(
    `https://localhost:7520/projects/${projectId}/routes`,
    createRouteCommand,
    options,
  );
};

export const getCreateRouteMutationOptions = <
  TError = AxiosError<unknown>,
  TContext = unknown,
>(options?: {
  mutation?: UseMutationOptions<
    Awaited<ReturnType<typeof createRoute>>,
    TError,
    { projectId: string; data: CreateRouteCommand },
    TContext
  >;
  axios?: AxiosRequestConfig;
}): UseMutationOptions<
  Awaited<ReturnType<typeof createRoute>>,
  TError,
  { projectId: string; data: CreateRouteCommand },
  TContext
> => {
  const mutationKey = ["createRoute"];
  const { mutation: mutationOptions, axios: axiosOptions } = options
    ? options.mutation &&
      "mutationKey" in options.mutation &&
      options.mutation.mutationKey
      ? options
      : { ...options, mutation: { ...options.mutation, mutationKey } }
    : { mutation: { mutationKey }, axios: undefined };

  const mutationFn: MutationFunction<
    Awaited<ReturnType<typeof createRoute>>,
    { projectId: string; data: CreateRouteCommand }
  > = (props) => {
    const { projectId, data } = props ?? {};

    return createRoute(projectId, data, axiosOptions);
  };

  return { mutationFn, ...mutationOptions };
};

export type CreateRouteMutationResult = NonNullable<
  Awaited<ReturnType<typeof createRoute>>
>;
export type CreateRouteMutationBody = CreateRouteCommand;
export type CreateRouteMutationError = AxiosError<unknown>;

export const useCreateRoute = <
  TError = AxiosError<unknown>,
  TContext = unknown,
>(
  options?: {
    mutation?: UseMutationOptions<
      Awaited<ReturnType<typeof createRoute>>,
      TError,
      { projectId: string; data: CreateRouteCommand },
      TContext
    >;
    axios?: AxiosRequestConfig;
  },
  queryClient?: QueryClient,
): UseMutationResult<
  Awaited<ReturnType<typeof createRoute>>,
  TError,
  { projectId: string; data: CreateRouteCommand },
  TContext
> => {
  const mutationOptions = getCreateRouteMutationOptions(options);

  return useMutation(mutationOptions, queryClient);
};

export const getAllRoutes = (
  projectId: string,
  options?: AxiosRequestConfig,
): Promise<AxiosResponse<RouteDto[]>> => {
  return axios.default.get(
    `https://localhost:7520/projects/${projectId}/routes`,
    options,
  );
};

export const getGetAllRoutesQueryKey = (projectId: string) => {
  return [`https://localhost:7520/projects/${projectId}/routes`] as const;
};

export const getGetAllRoutesQueryOptions = <
  TData = Awaited<ReturnType<typeof getAllRoutes>>,
  TError = AxiosError<unknown>,
>(
  projectId: string,
  options?: {
    query?: Partial<
      UseQueryOptions<Awaited<ReturnType<typeof getAllRoutes>>, TError, TData>
    >;
    axios?: AxiosRequestConfig;
  },
) => {
  const { query: queryOptions, axios: axiosOptions } = options ?? {};

  const queryKey = queryOptions?.queryKey ?? getGetAllRoutesQueryKey(projectId);

  const queryFn: QueryFunction<Awaited<ReturnType<typeof getAllRoutes>>> = ({
    signal,
  }) => getAllRoutes(projectId, { signal, ...axiosOptions });

  return {
    queryKey,
    queryFn,
    enabled: !!projectId,
    ...queryOptions,
  } as UseQueryOptions<
    Awaited<ReturnType<typeof getAllRoutes>>,
    TError,
    TData
  > & { queryKey: DataTag<QueryKey, TData, TError> };
};

export type GetAllRoutesQueryResult = NonNullable<
  Awaited<ReturnType<typeof getAllRoutes>>
>;
export type GetAllRoutesQueryError = AxiosError<unknown>;

export function useGetAllRoutes<
  TData = Awaited<ReturnType<typeof getAllRoutes>>,
  TError = AxiosError<unknown>,
>(
  projectId: string,
  options: {
    query: Partial<
      UseQueryOptions<Awaited<ReturnType<typeof getAllRoutes>>, TError, TData>
    > &
      Pick<
        DefinedInitialDataOptions<
          Awaited<ReturnType<typeof getAllRoutes>>,
          TError,
          Awaited<ReturnType<typeof getAllRoutes>>
        >,
        "initialData"
      >;
    axios?: AxiosRequestConfig;
  },
  queryClient?: QueryClient,
): DefinedUseQueryResult<TData, TError> & {
  queryKey: DataTag<QueryKey, TData, TError>;
};
export function useGetAllRoutes<
  TData = Awaited<ReturnType<typeof getAllRoutes>>,
  TError = AxiosError<unknown>,
>(
  projectId: string,
  options?: {
    query?: Partial<
      UseQueryOptions<Awaited<ReturnType<typeof getAllRoutes>>, TError, TData>
    > &
      Pick<
        UndefinedInitialDataOptions<
          Awaited<ReturnType<typeof getAllRoutes>>,
          TError,
          Awaited<ReturnType<typeof getAllRoutes>>
        >,
        "initialData"
      >;
    axios?: AxiosRequestConfig;
  },
  queryClient?: QueryClient,
): UseQueryResult<TData, TError> & {
  queryKey: DataTag<QueryKey, TData, TError>;
};
export function useGetAllRoutes<
  TData = Awaited<ReturnType<typeof getAllRoutes>>,
  TError = AxiosError<unknown>,
>(
  projectId: string,
  options?: {
    query?: Partial<
      UseQueryOptions<Awaited<ReturnType<typeof getAllRoutes>>, TError, TData>
    >;
    axios?: AxiosRequestConfig;
  },
  queryClient?: QueryClient,
): UseQueryResult<TData, TError> & {
  queryKey: DataTag<QueryKey, TData, TError>;
};

export function useGetAllRoutes<
  TData = Awaited<ReturnType<typeof getAllRoutes>>,
  TError = AxiosError<unknown>,
>(
  projectId: string,
  options?: {
    query?: Partial<
      UseQueryOptions<Awaited<ReturnType<typeof getAllRoutes>>, TError, TData>
    >;
    axios?: AxiosRequestConfig;
  },
  queryClient?: QueryClient,
): UseQueryResult<TData, TError> & {
  queryKey: DataTag<QueryKey, TData, TError>;
} {
  const queryOptions = getGetAllRoutesQueryOptions(projectId, options);

  const query = useQuery(queryOptions, queryClient) as UseQueryResult<
    TData,
    TError
  > & { queryKey: DataTag<QueryKey, TData, TError> };

  query.queryKey = queryOptions.queryKey;

  return query;
}

export const updateRoute = (
  projectId: string,
  routeId: string,
  updateRouteCommand: UpdateRouteCommand,
  options?: AxiosRequestConfig,
): Promise<AxiosResponse<void>> => {
  return axios.default.put(
    `https://localhost:7520/projects/${projectId}/routes/${routeId}`,
    updateRouteCommand,
    options,
  );
};

export const getUpdateRouteMutationOptions = <
  TError = AxiosError<unknown>,
  TContext = unknown,
>(options?: {
  mutation?: UseMutationOptions<
    Awaited<ReturnType<typeof updateRoute>>,
    TError,
    { projectId: string; routeId: string; data: UpdateRouteCommand },
    TContext
  >;
  axios?: AxiosRequestConfig;
}): UseMutationOptions<
  Awaited<ReturnType<typeof updateRoute>>,
  TError,
  { projectId: string; routeId: string; data: UpdateRouteCommand },
  TContext
> => {
  const mutationKey = ["updateRoute"];
  const { mutation: mutationOptions, axios: axiosOptions } = options
    ? options.mutation &&
      "mutationKey" in options.mutation &&
      options.mutation.mutationKey
      ? options
      : { ...options, mutation: { ...options.mutation, mutationKey } }
    : { mutation: { mutationKey }, axios: undefined };

  const mutationFn: MutationFunction<
    Awaited<ReturnType<typeof updateRoute>>,
    { projectId: string; routeId: string; data: UpdateRouteCommand }
  > = (props) => {
    const { projectId, routeId, data } = props ?? {};

    return updateRoute(projectId, routeId, data, axiosOptions);
  };

  return { mutationFn, ...mutationOptions };
};

export type UpdateRouteMutationResult = NonNullable<
  Awaited<ReturnType<typeof updateRoute>>
>;
export type UpdateRouteMutationBody = UpdateRouteCommand;
export type UpdateRouteMutationError = AxiosError<unknown>;

export const useUpdateRoute = <
  TError = AxiosError<unknown>,
  TContext = unknown,
>(
  options?: {
    mutation?: UseMutationOptions<
      Awaited<ReturnType<typeof updateRoute>>,
      TError,
      { projectId: string; routeId: string; data: UpdateRouteCommand },
      TContext
    >;
    axios?: AxiosRequestConfig;
  },
  queryClient?: QueryClient,
): UseMutationResult<
  Awaited<ReturnType<typeof updateRoute>>,
  TError,
  { projectId: string; routeId: string; data: UpdateRouteCommand },
  TContext
> => {
  const mutationOptions = getUpdateRouteMutationOptions(options);

  return useMutation(mutationOptions, queryClient);
};

export const deleteRoute = (
  projectId: string,
  routeId: string,
  options?: AxiosRequestConfig,
): Promise<AxiosResponse<void>> => {
  return axios.default.delete(
    `https://localhost:7520/projects/${projectId}/routes/${routeId}`,
    options,
  );
};

export const getDeleteRouteMutationOptions = <
  TError = AxiosError<unknown>,
  TContext = unknown,
>(options?: {
  mutation?: UseMutationOptions<
    Awaited<ReturnType<typeof deleteRoute>>,
    TError,
    { projectId: string; routeId: string },
    TContext
  >;
  axios?: AxiosRequestConfig;
}): UseMutationOptions<
  Awaited<ReturnType<typeof deleteRoute>>,
  TError,
  { projectId: string; routeId: string },
  TContext
> => {
  const mutationKey = ["deleteRoute"];
  const { mutation: mutationOptions, axios: axiosOptions } = options
    ? options.mutation &&
      "mutationKey" in options.mutation &&
      options.mutation.mutationKey
      ? options
      : { ...options, mutation: { ...options.mutation, mutationKey } }
    : { mutation: { mutationKey }, axios: undefined };

  const mutationFn: MutationFunction<
    Awaited<ReturnType<typeof deleteRoute>>,
    { projectId: string; routeId: string }
  > = (props) => {
    const { projectId, routeId } = props ?? {};

    return deleteRoute(projectId, routeId, axiosOptions);
  };

  return { mutationFn, ...mutationOptions };
};

export type DeleteRouteMutationResult = NonNullable<
  Awaited<ReturnType<typeof deleteRoute>>
>;

export type DeleteRouteMutationError = AxiosError<unknown>;

export const useDeleteRoute = <
  TError = AxiosError<unknown>,
  TContext = unknown,
>(
  options?: {
    mutation?: UseMutationOptions<
      Awaited<ReturnType<typeof deleteRoute>>,
      TError,
      { projectId: string; routeId: string },
      TContext
    >;
    axios?: AxiosRequestConfig;
  },
  queryClient?: QueryClient,
): UseMutationResult<
  Awaited<ReturnType<typeof deleteRoute>>,
  TError,
  { projectId: string; routeId: string },
  TContext
> => {
  const mutationOptions = getDeleteRouteMutationOptions(options);

  return useMutation(mutationOptions, queryClient);
};

export const getRoute = (
  projectId: string,
  routeId: string,
  options?: AxiosRequestConfig,
): Promise<AxiosResponse<RouteDto>> => {
  return axios.default.get(
    `https://localhost:7520/projects/${projectId}/routes/${routeId}`,
    options,
  );
};

export const getGetRouteQueryKey = (projectId: string, routeId: string) => {
  return [
    `https://localhost:7520/projects/${projectId}/routes/${routeId}`,
  ] as const;
};

export const getGetRouteQueryOptions = <
  TData = Awaited<ReturnType<typeof getRoute>>,
  TError = AxiosError<ProblemDetails>,
>(
  projectId: string,
  routeId: string,
  options?: {
    query?: Partial<
      UseQueryOptions<Awaited<ReturnType<typeof getRoute>>, TError, TData>
    >;
    axios?: AxiosRequestConfig;
  },
) => {
  const { query: queryOptions, axios: axiosOptions } = options ?? {};

  const queryKey =
    queryOptions?.queryKey ?? getGetRouteQueryKey(projectId, routeId);

  const queryFn: QueryFunction<Awaited<ReturnType<typeof getRoute>>> = ({
    signal,
  }) => getRoute(projectId, routeId, { signal, ...axiosOptions });

  return {
    queryKey,
    queryFn,
    enabled: !!(projectId && routeId),
    ...queryOptions,
  } as UseQueryOptions<Awaited<ReturnType<typeof getRoute>>, TError, TData> & {
    queryKey: DataTag<QueryKey, TData, TError>;
  };
};

export type GetRouteQueryResult = NonNullable<
  Awaited<ReturnType<typeof getRoute>>
>;
export type GetRouteQueryError = AxiosError<ProblemDetails>;

export function useGetRoute<
  TData = Awaited<ReturnType<typeof getRoute>>,
  TError = AxiosError<ProblemDetails>,
>(
  projectId: string,
  routeId: string,
  options: {
    query: Partial<
      UseQueryOptions<Awaited<ReturnType<typeof getRoute>>, TError, TData>
    > &
      Pick<
        DefinedInitialDataOptions<
          Awaited<ReturnType<typeof getRoute>>,
          TError,
          Awaited<ReturnType<typeof getRoute>>
        >,
        "initialData"
      >;
    axios?: AxiosRequestConfig;
  },
  queryClient?: QueryClient,
): DefinedUseQueryResult<TData, TError> & {
  queryKey: DataTag<QueryKey, TData, TError>;
};
export function useGetRoute<
  TData = Awaited<ReturnType<typeof getRoute>>,
  TError = AxiosError<ProblemDetails>,
>(
  projectId: string,
  routeId: string,
  options?: {
    query?: Partial<
      UseQueryOptions<Awaited<ReturnType<typeof getRoute>>, TError, TData>
    > &
      Pick<
        UndefinedInitialDataOptions<
          Awaited<ReturnType<typeof getRoute>>,
          TError,
          Awaited<ReturnType<typeof getRoute>>
        >,
        "initialData"
      >;
    axios?: AxiosRequestConfig;
  },
  queryClient?: QueryClient,
): UseQueryResult<TData, TError> & {
  queryKey: DataTag<QueryKey, TData, TError>;
};
export function useGetRoute<
  TData = Awaited<ReturnType<typeof getRoute>>,
  TError = AxiosError<ProblemDetails>,
>(
  projectId: string,
  routeId: string,
  options?: {
    query?: Partial<
      UseQueryOptions<Awaited<ReturnType<typeof getRoute>>, TError, TData>
    >;
    axios?: AxiosRequestConfig;
  },
  queryClient?: QueryClient,
): UseQueryResult<TData, TError> & {
  queryKey: DataTag<QueryKey, TData, TError>;
};

export function useGetRoute<
  TData = Awaited<ReturnType<typeof getRoute>>,
  TError = AxiosError<ProblemDetails>,
>(
  projectId: string,
  routeId: string,
  options?: {
    query?: Partial<
      UseQueryOptions<Awaited<ReturnType<typeof getRoute>>, TError, TData>
    >;
    axios?: AxiosRequestConfig;
  },
  queryClient?: QueryClient,
): UseQueryResult<TData, TError> & {
  queryKey: DataTag<QueryKey, TData, TError>;
} {
  const queryOptions = getGetRouteQueryOptions(projectId, routeId, options);

  const query = useQuery(queryOptions, queryClient) as UseQueryResult<
    TData,
    TError
  > & { queryKey: DataTag<QueryKey, TData, TError> };

  query.queryKey = queryOptions.queryKey;

  return query;
}

export const addStop = (
  projectId: string,
  routeId: string,
  addStopCommand: AddStopCommand,
  options?: AxiosRequestConfig,
): Promise<AxiosResponse<void>> => {
  return axios.default.post(
    `https://localhost:7520/projects/${projectId}/routes/${routeId}/stops`,
    addStopCommand,
    options,
  );
};

export const getAddStopMutationOptions = <
  TError = AxiosError<unknown>,
  TContext = unknown,
>(options?: {
  mutation?: UseMutationOptions<
    Awaited<ReturnType<typeof addStop>>,
    TError,
    { projectId: string; routeId: string; data: AddStopCommand },
    TContext
  >;
  axios?: AxiosRequestConfig;
}): UseMutationOptions<
  Awaited<ReturnType<typeof addStop>>,
  TError,
  { projectId: string; routeId: string; data: AddStopCommand },
  TContext
> => {
  const mutationKey = ["addStop"];
  const { mutation: mutationOptions, axios: axiosOptions } = options
    ? options.mutation &&
      "mutationKey" in options.mutation &&
      options.mutation.mutationKey
      ? options
      : { ...options, mutation: { ...options.mutation, mutationKey } }
    : { mutation: { mutationKey }, axios: undefined };

  const mutationFn: MutationFunction<
    Awaited<ReturnType<typeof addStop>>,
    { projectId: string; routeId: string; data: AddStopCommand }
  > = (props) => {
    const { projectId, routeId, data } = props ?? {};

    return addStop(projectId, routeId, data, axiosOptions);
  };

  return { mutationFn, ...mutationOptions };
};

export type AddStopMutationResult = NonNullable<
  Awaited<ReturnType<typeof addStop>>
>;
export type AddStopMutationBody = AddStopCommand;
export type AddStopMutationError = AxiosError<unknown>;

export const useAddStop = <TError = AxiosError<unknown>, TContext = unknown>(
  options?: {
    mutation?: UseMutationOptions<
      Awaited<ReturnType<typeof addStop>>,
      TError,
      { projectId: string; routeId: string; data: AddStopCommand },
      TContext
    >;
    axios?: AxiosRequestConfig;
  },
  queryClient?: QueryClient,
): UseMutationResult<
  Awaited<ReturnType<typeof addStop>>,
  TError,
  { projectId: string; routeId: string; data: AddStopCommand },
  TContext
> => {
  const mutationOptions = getAddStopMutationOptions(options);

  return useMutation(mutationOptions, queryClient);
};

export const removeStop = (
  projectId: string,
  routeId: string,
  stopId: string,
  options?: AxiosRequestConfig,
): Promise<AxiosResponse<void>> => {
  return axios.default.delete(
    `https://localhost:7520/projects/${projectId}/routes/${routeId}/stops/${stopId}`,
    options,
  );
};

export const getRemoveStopMutationOptions = <
  TError = AxiosError<unknown>,
  TContext = unknown,
>(options?: {
  mutation?: UseMutationOptions<
    Awaited<ReturnType<typeof removeStop>>,
    TError,
    { projectId: string; routeId: string; stopId: string },
    TContext
  >;
  axios?: AxiosRequestConfig;
}): UseMutationOptions<
  Awaited<ReturnType<typeof removeStop>>,
  TError,
  { projectId: string; routeId: string; stopId: string },
  TContext
> => {
  const mutationKey = ["removeStop"];
  const { mutation: mutationOptions, axios: axiosOptions } = options
    ? options.mutation &&
      "mutationKey" in options.mutation &&
      options.mutation.mutationKey
      ? options
      : { ...options, mutation: { ...options.mutation, mutationKey } }
    : { mutation: { mutationKey }, axios: undefined };

  const mutationFn: MutationFunction<
    Awaited<ReturnType<typeof removeStop>>,
    { projectId: string; routeId: string; stopId: string }
  > = (props) => {
    const { projectId, routeId, stopId } = props ?? {};

    return removeStop(projectId, routeId, stopId, axiosOptions);
  };

  return { mutationFn, ...mutationOptions };
};

export type RemoveStopMutationResult = NonNullable<
  Awaited<ReturnType<typeof removeStop>>
>;

export type RemoveStopMutationError = AxiosError<unknown>;

export const useRemoveStop = <TError = AxiosError<unknown>, TContext = unknown>(
  options?: {
    mutation?: UseMutationOptions<
      Awaited<ReturnType<typeof removeStop>>,
      TError,
      { projectId: string; routeId: string; stopId: string },
      TContext
    >;
    axios?: AxiosRequestConfig;
  },
  queryClient?: QueryClient,
): UseMutationResult<
  Awaited<ReturnType<typeof removeStop>>,
  TError,
  { projectId: string; routeId: string; stopId: string },
  TContext
> => {
  const mutationOptions = getRemoveStopMutationOptions(options);

  return useMutation(mutationOptions, queryClient);
};

export const assignTeam = (
  projectId: string,
  routeId: string,
  assignTeamCommand: AssignTeamCommand,
  options?: AxiosRequestConfig,
): Promise<AxiosResponse<void>> => {
  return axios.default.put(
    `https://localhost:7520/projects/${projectId}/routes/${routeId}/team`,
    assignTeamCommand,
    options,
  );
};

export const getAssignTeamMutationOptions = <
  TError = AxiosError<unknown>,
  TContext = unknown,
>(options?: {
  mutation?: UseMutationOptions<
    Awaited<ReturnType<typeof assignTeam>>,
    TError,
    { projectId: string; routeId: string; data: AssignTeamCommand },
    TContext
  >;
  axios?: AxiosRequestConfig;
}): UseMutationOptions<
  Awaited<ReturnType<typeof assignTeam>>,
  TError,
  { projectId: string; routeId: string; data: AssignTeamCommand },
  TContext
> => {
  const mutationKey = ["assignTeam"];
  const { mutation: mutationOptions, axios: axiosOptions } = options
    ? options.mutation &&
      "mutationKey" in options.mutation &&
      options.mutation.mutationKey
      ? options
      : { ...options, mutation: { ...options.mutation, mutationKey } }
    : { mutation: { mutationKey }, axios: undefined };

  const mutationFn: MutationFunction<
    Awaited<ReturnType<typeof assignTeam>>,
    { projectId: string; routeId: string; data: AssignTeamCommand }
  > = (props) => {
    const { projectId, routeId, data } = props ?? {};

    return assignTeam(projectId, routeId, data, axiosOptions);
  };

  return { mutationFn, ...mutationOptions };
};

export type AssignTeamMutationResult = NonNullable<
  Awaited<ReturnType<typeof assignTeam>>
>;
export type AssignTeamMutationBody = AssignTeamCommand;
export type AssignTeamMutationError = AxiosError<unknown>;

export const useAssignTeam = <TError = AxiosError<unknown>, TContext = unknown>(
  options?: {
    mutation?: UseMutationOptions<
      Awaited<ReturnType<typeof assignTeam>>,
      TError,
      { projectId: string; routeId: string; data: AssignTeamCommand },
      TContext
    >;
    axios?: AxiosRequestConfig;
  },
  queryClient?: QueryClient,
): UseMutationResult<
  Awaited<ReturnType<typeof assignTeam>>,
  TError,
  { projectId: string; routeId: string; data: AssignTeamCommand },
  TContext
> => {
  const mutationOptions = getAssignTeamMutationOptions(options);

  return useMutation(mutationOptions, queryClient);
};

export const unassignTeam = (
  projectId: string,
  routeId: string,
  options?: AxiosRequestConfig,
): Promise<AxiosResponse<void>> => {
  return axios.default.delete(
    `https://localhost:7520/projects/${projectId}/routes/${routeId}/team`,
    options,
  );
};

export const getUnassignTeamMutationOptions = <
  TError = AxiosError<unknown>,
  TContext = unknown,
>(options?: {
  mutation?: UseMutationOptions<
    Awaited<ReturnType<typeof unassignTeam>>,
    TError,
    { projectId: string; routeId: string },
    TContext
  >;
  axios?: AxiosRequestConfig;
}): UseMutationOptions<
  Awaited<ReturnType<typeof unassignTeam>>,
  TError,
  { projectId: string; routeId: string },
  TContext
> => {
  const mutationKey = ["unassignTeam"];
  const { mutation: mutationOptions, axios: axiosOptions } = options
    ? options.mutation &&
      "mutationKey" in options.mutation &&
      options.mutation.mutationKey
      ? options
      : { ...options, mutation: { ...options.mutation, mutationKey } }
    : { mutation: { mutationKey }, axios: undefined };

  const mutationFn: MutationFunction<
    Awaited<ReturnType<typeof unassignTeam>>,
    { projectId: string; routeId: string }
  > = (props) => {
    const { projectId, routeId } = props ?? {};

    return unassignTeam(projectId, routeId, axiosOptions);
  };

  return { mutationFn, ...mutationOptions };
};

export type UnassignTeamMutationResult = NonNullable<
  Awaited<ReturnType<typeof unassignTeam>>
>;

export type UnassignTeamMutationError = AxiosError<unknown>;

export const useUnassignTeam = <
  TError = AxiosError<unknown>,
  TContext = unknown,
>(
  options?: {
    mutation?: UseMutationOptions<
      Awaited<ReturnType<typeof unassignTeam>>,
      TError,
      { projectId: string; routeId: string },
      TContext
    >;
    axios?: AxiosRequestConfig;
  },
  queryClient?: QueryClient,
): UseMutationResult<
  Awaited<ReturnType<typeof unassignTeam>>,
  TError,
  { projectId: string; routeId: string },
  TContext
> => {
  const mutationOptions = getUnassignTeamMutationOptions(options);

  return useMutation(mutationOptions, queryClient);
};

export const getRoutesForTeam = (
  projectId: string,
  teamId: string,
  options?: AxiosRequestConfig,
): Promise<AxiosResponse<RouteDto[]>> => {
  return axios.default.get(
    `https://localhost:7520/projects/${projectId}/routes/team/${teamId}`,
    options,
  );
};

export const getGetRoutesForTeamQueryKey = (
  projectId: string,
  teamId: string,
) => {
  return [
    `https://localhost:7520/projects/${projectId}/routes/team/${teamId}`,
  ] as const;
};

export const getGetRoutesForTeamQueryOptions = <
  TData = Awaited<ReturnType<typeof getRoutesForTeam>>,
  TError = AxiosError<unknown>,
>(
  projectId: string,
  teamId: string,
  options?: {
    query?: Partial<
      UseQueryOptions<
        Awaited<ReturnType<typeof getRoutesForTeam>>,
        TError,
        TData
      >
    >;
    axios?: AxiosRequestConfig;
  },
) => {
  const { query: queryOptions, axios: axiosOptions } = options ?? {};

  const queryKey =
    queryOptions?.queryKey ?? getGetRoutesForTeamQueryKey(projectId, teamId);

  const queryFn: QueryFunction<
    Awaited<ReturnType<typeof getRoutesForTeam>>
  > = ({ signal }) =>
    getRoutesForTeam(projectId, teamId, { signal, ...axiosOptions });

  return {
    queryKey,
    queryFn,
    enabled: !!(projectId && teamId),
    ...queryOptions,
  } as UseQueryOptions<
    Awaited<ReturnType<typeof getRoutesForTeam>>,
    TError,
    TData
  > & { queryKey: DataTag<QueryKey, TData, TError> };
};

export type GetRoutesForTeamQueryResult = NonNullable<
  Awaited<ReturnType<typeof getRoutesForTeam>>
>;
export type GetRoutesForTeamQueryError = AxiosError<unknown>;

export function useGetRoutesForTeam<
  TData = Awaited<ReturnType<typeof getRoutesForTeam>>,
  TError = AxiosError<unknown>,
>(
  projectId: string,
  teamId: string,
  options: {
    query: Partial<
      UseQueryOptions<
        Awaited<ReturnType<typeof getRoutesForTeam>>,
        TError,
        TData
      >
    > &
      Pick<
        DefinedInitialDataOptions<
          Awaited<ReturnType<typeof getRoutesForTeam>>,
          TError,
          Awaited<ReturnType<typeof getRoutesForTeam>>
        >,
        "initialData"
      >;
    axios?: AxiosRequestConfig;
  },
  queryClient?: QueryClient,
): DefinedUseQueryResult<TData, TError> & {
  queryKey: DataTag<QueryKey, TData, TError>;
};
export function useGetRoutesForTeam<
  TData = Awaited<ReturnType<typeof getRoutesForTeam>>,
  TError = AxiosError<unknown>,
>(
  projectId: string,
  teamId: string,
  options?: {
    query?: Partial<
      UseQueryOptions<
        Awaited<ReturnType<typeof getRoutesForTeam>>,
        TError,
        TData
      >
    > &
      Pick<
        UndefinedInitialDataOptions<
          Awaited<ReturnType<typeof getRoutesForTeam>>,
          TError,
          Awaited<ReturnType<typeof getRoutesForTeam>>
        >,
        "initialData"
      >;
    axios?: AxiosRequestConfig;
  },
  queryClient?: QueryClient,
): UseQueryResult<TData, TError> & {
  queryKey: DataTag<QueryKey, TData, TError>;
};
export function useGetRoutesForTeam<
  TData = Awaited<ReturnType<typeof getRoutesForTeam>>,
  TError = AxiosError<unknown>,
>(
  projectId: string,
  teamId: string,
  options?: {
    query?: Partial<
      UseQueryOptions<
        Awaited<ReturnType<typeof getRoutesForTeam>>,
        TError,
        TData
      >
    >;
    axios?: AxiosRequestConfig;
  },
  queryClient?: QueryClient,
): UseQueryResult<TData, TError> & {
  queryKey: DataTag<QueryKey, TData, TError>;
};

export function useGetRoutesForTeam<
  TData = Awaited<ReturnType<typeof getRoutesForTeam>>,
  TError = AxiosError<unknown>,
>(
  projectId: string,
  teamId: string,
  options?: {
    query?: Partial<
      UseQueryOptions<
        Awaited<ReturnType<typeof getRoutesForTeam>>,
        TError,
        TData
      >
    >;
    axios?: AxiosRequestConfig;
  },
  queryClient?: QueryClient,
): UseQueryResult<TData, TError> & {
  queryKey: DataTag<QueryKey, TData, TError>;
} {
  const queryOptions = getGetRoutesForTeamQueryOptions(
    projectId,
    teamId,
    options,
  );

  const query = useQuery(queryOptions, queryClient) as UseQueryResult<
    TData,
    TError
  > & { queryKey: DataTag<QueryKey, TData, TError> };

  query.queryKey = queryOptions.queryKey;

  return query;
}

export const createStop = (
  projectId: string,
  createStopCommand: CreateStopCommand,
  options?: AxiosRequestConfig,
): Promise<AxiosResponse<void>> => {
  return axios.default.post(
    `https://localhost:7520/projects/${projectId}/stops`,
    createStopCommand,
    options,
  );
};

export const getCreateStopMutationOptions = <
  TError = AxiosError<unknown>,
  TContext = unknown,
>(options?: {
  mutation?: UseMutationOptions<
    Awaited<ReturnType<typeof createStop>>,
    TError,
    { projectId: string; data: CreateStopCommand },
    TContext
  >;
  axios?: AxiosRequestConfig;
}): UseMutationOptions<
  Awaited<ReturnType<typeof createStop>>,
  TError,
  { projectId: string; data: CreateStopCommand },
  TContext
> => {
  const mutationKey = ["createStop"];
  const { mutation: mutationOptions, axios: axiosOptions } = options
    ? options.mutation &&
      "mutationKey" in options.mutation &&
      options.mutation.mutationKey
      ? options
      : { ...options, mutation: { ...options.mutation, mutationKey } }
    : { mutation: { mutationKey }, axios: undefined };

  const mutationFn: MutationFunction<
    Awaited<ReturnType<typeof createStop>>,
    { projectId: string; data: CreateStopCommand }
  > = (props) => {
    const { projectId, data } = props ?? {};

    return createStop(projectId, data, axiosOptions);
  };

  return { mutationFn, ...mutationOptions };
};

export type CreateStopMutationResult = NonNullable<
  Awaited<ReturnType<typeof createStop>>
>;
export type CreateStopMutationBody = CreateStopCommand;
export type CreateStopMutationError = AxiosError<unknown>;

export const useCreateStop = <TError = AxiosError<unknown>, TContext = unknown>(
  options?: {
    mutation?: UseMutationOptions<
      Awaited<ReturnType<typeof createStop>>,
      TError,
      { projectId: string; data: CreateStopCommand },
      TContext
    >;
    axios?: AxiosRequestConfig;
  },
  queryClient?: QueryClient,
): UseMutationResult<
  Awaited<ReturnType<typeof createStop>>,
  TError,
  { projectId: string; data: CreateStopCommand },
  TContext
> => {
  const mutationOptions = getCreateStopMutationOptions(options);

  return useMutation(mutationOptions, queryClient);
};

export const getAllStops = (
  projectId: string,
  options?: AxiosRequestConfig,
): Promise<AxiosResponse<StopDto[]>> => {
  return axios.default.get(
    `https://localhost:7520/projects/${projectId}/stops`,
    options,
  );
};

export const getGetAllStopsQueryKey = (projectId: string) => {
  return [`https://localhost:7520/projects/${projectId}/stops`] as const;
};

export const getGetAllStopsQueryOptions = <
  TData = Awaited<ReturnType<typeof getAllStops>>,
  TError = AxiosError<unknown>,
>(
  projectId: string,
  options?: {
    query?: Partial<
      UseQueryOptions<Awaited<ReturnType<typeof getAllStops>>, TError, TData>
    >;
    axios?: AxiosRequestConfig;
  },
) => {
  const { query: queryOptions, axios: axiosOptions } = options ?? {};

  const queryKey = queryOptions?.queryKey ?? getGetAllStopsQueryKey(projectId);

  const queryFn: QueryFunction<Awaited<ReturnType<typeof getAllStops>>> = ({
    signal,
  }) => getAllStops(projectId, { signal, ...axiosOptions });

  return {
    queryKey,
    queryFn,
    enabled: !!projectId,
    ...queryOptions,
  } as UseQueryOptions<
    Awaited<ReturnType<typeof getAllStops>>,
    TError,
    TData
  > & { queryKey: DataTag<QueryKey, TData, TError> };
};

export type GetAllStopsQueryResult = NonNullable<
  Awaited<ReturnType<typeof getAllStops>>
>;
export type GetAllStopsQueryError = AxiosError<unknown>;

export function useGetAllStops<
  TData = Awaited<ReturnType<typeof getAllStops>>,
  TError = AxiosError<unknown>,
>(
  projectId: string,
  options: {
    query: Partial<
      UseQueryOptions<Awaited<ReturnType<typeof getAllStops>>, TError, TData>
    > &
      Pick<
        DefinedInitialDataOptions<
          Awaited<ReturnType<typeof getAllStops>>,
          TError,
          Awaited<ReturnType<typeof getAllStops>>
        >,
        "initialData"
      >;
    axios?: AxiosRequestConfig;
  },
  queryClient?: QueryClient,
): DefinedUseQueryResult<TData, TError> & {
  queryKey: DataTag<QueryKey, TData, TError>;
};
export function useGetAllStops<
  TData = Awaited<ReturnType<typeof getAllStops>>,
  TError = AxiosError<unknown>,
>(
  projectId: string,
  options?: {
    query?: Partial<
      UseQueryOptions<Awaited<ReturnType<typeof getAllStops>>, TError, TData>
    > &
      Pick<
        UndefinedInitialDataOptions<
          Awaited<ReturnType<typeof getAllStops>>,
          TError,
          Awaited<ReturnType<typeof getAllStops>>
        >,
        "initialData"
      >;
    axios?: AxiosRequestConfig;
  },
  queryClient?: QueryClient,
): UseQueryResult<TData, TError> & {
  queryKey: DataTag<QueryKey, TData, TError>;
};
export function useGetAllStops<
  TData = Awaited<ReturnType<typeof getAllStops>>,
  TError = AxiosError<unknown>,
>(
  projectId: string,
  options?: {
    query?: Partial<
      UseQueryOptions<Awaited<ReturnType<typeof getAllStops>>, TError, TData>
    >;
    axios?: AxiosRequestConfig;
  },
  queryClient?: QueryClient,
): UseQueryResult<TData, TError> & {
  queryKey: DataTag<QueryKey, TData, TError>;
};

export function useGetAllStops<
  TData = Awaited<ReturnType<typeof getAllStops>>,
  TError = AxiosError<unknown>,
>(
  projectId: string,
  options?: {
    query?: Partial<
      UseQueryOptions<Awaited<ReturnType<typeof getAllStops>>, TError, TData>
    >;
    axios?: AxiosRequestConfig;
  },
  queryClient?: QueryClient,
): UseQueryResult<TData, TError> & {
  queryKey: DataTag<QueryKey, TData, TError>;
} {
  const queryOptions = getGetAllStopsQueryOptions(projectId, options);

  const query = useQuery(queryOptions, queryClient) as UseQueryResult<
    TData,
    TError
  > & { queryKey: DataTag<QueryKey, TData, TError> };

  query.queryKey = queryOptions.queryKey;

  return query;
}

export const completeStop = (
  projectId: string,
  stopId: string,
  options?: AxiosRequestConfig,
): Promise<AxiosResponse<void>> => {
  return axios.default.put(
    `https://localhost:7520/projects/${projectId}/stops/${stopId}/completed`,
    undefined,
    options,
  );
};

export const getCompleteStopMutationOptions = <
  TError = AxiosError<unknown>,
  TContext = unknown,
>(options?: {
  mutation?: UseMutationOptions<
    Awaited<ReturnType<typeof completeStop>>,
    TError,
    { projectId: string; stopId: string },
    TContext
  >;
  axios?: AxiosRequestConfig;
}): UseMutationOptions<
  Awaited<ReturnType<typeof completeStop>>,
  TError,
  { projectId: string; stopId: string },
  TContext
> => {
  const mutationKey = ["completeStop"];
  const { mutation: mutationOptions, axios: axiosOptions } = options
    ? options.mutation &&
      "mutationKey" in options.mutation &&
      options.mutation.mutationKey
      ? options
      : { ...options, mutation: { ...options.mutation, mutationKey } }
    : { mutation: { mutationKey }, axios: undefined };

  const mutationFn: MutationFunction<
    Awaited<ReturnType<typeof completeStop>>,
    { projectId: string; stopId: string }
  > = (props) => {
    const { projectId, stopId } = props ?? {};

    return completeStop(projectId, stopId, axiosOptions);
  };

  return { mutationFn, ...mutationOptions };
};

export type CompleteStopMutationResult = NonNullable<
  Awaited<ReturnType<typeof completeStop>>
>;

export type CompleteStopMutationError = AxiosError<unknown>;

export const useCompleteStop = <
  TError = AxiosError<unknown>,
  TContext = unknown,
>(
  options?: {
    mutation?: UseMutationOptions<
      Awaited<ReturnType<typeof completeStop>>,
      TError,
      { projectId: string; stopId: string },
      TContext
    >;
    axios?: AxiosRequestConfig;
  },
  queryClient?: QueryClient,
): UseMutationResult<
  Awaited<ReturnType<typeof completeStop>>,
  TError,
  { projectId: string; stopId: string },
  TContext
> => {
  const mutationOptions = getCompleteStopMutationOptions(options);

  return useMutation(mutationOptions, queryClient);
};

export const deleteStop = (
  projectId: string,
  stopId: string,
  options?: AxiosRequestConfig,
): Promise<AxiosResponse<void>> => {
  return axios.default.delete(
    `https://localhost:7520/projects/${projectId}/stops/${stopId}`,
    options,
  );
};

export const getDeleteStopMutationOptions = <
  TError = AxiosError<unknown>,
  TContext = unknown,
>(options?: {
  mutation?: UseMutationOptions<
    Awaited<ReturnType<typeof deleteStop>>,
    TError,
    { projectId: string; stopId: string },
    TContext
  >;
  axios?: AxiosRequestConfig;
}): UseMutationOptions<
  Awaited<ReturnType<typeof deleteStop>>,
  TError,
  { projectId: string; stopId: string },
  TContext
> => {
  const mutationKey = ["deleteStop"];
  const { mutation: mutationOptions, axios: axiosOptions } = options
    ? options.mutation &&
      "mutationKey" in options.mutation &&
      options.mutation.mutationKey
      ? options
      : { ...options, mutation: { ...options.mutation, mutationKey } }
    : { mutation: { mutationKey }, axios: undefined };

  const mutationFn: MutationFunction<
    Awaited<ReturnType<typeof deleteStop>>,
    { projectId: string; stopId: string }
  > = (props) => {
    const { projectId, stopId } = props ?? {};

    return deleteStop(projectId, stopId, axiosOptions);
  };

  return { mutationFn, ...mutationOptions };
};

export type DeleteStopMutationResult = NonNullable<
  Awaited<ReturnType<typeof deleteStop>>
>;

export type DeleteStopMutationError = AxiosError<unknown>;

export const useDeleteStop = <TError = AxiosError<unknown>, TContext = unknown>(
  options?: {
    mutation?: UseMutationOptions<
      Awaited<ReturnType<typeof deleteStop>>,
      TError,
      { projectId: string; stopId: string },
      TContext
    >;
    axios?: AxiosRequestConfig;
  },
  queryClient?: QueryClient,
): UseMutationResult<
  Awaited<ReturnType<typeof deleteStop>>,
  TError,
  { projectId: string; stopId: string },
  TContext
> => {
  const mutationOptions = getDeleteStopMutationOptions(options);

  return useMutation(mutationOptions, queryClient);
};

export const addComment = (
  projectId: string,
  stopId: string,
  addCommentCommand: AddCommentCommand,
  options?: AxiosRequestConfig,
): Promise<AxiosResponse<void>> => {
  return axios.default.post(
    `https://localhost:7520/projects/${projectId}/stops/${stopId}/comments`,
    addCommentCommand,
    options,
  );
};

export const getAddCommentMutationOptions = <
  TError = AxiosError<unknown>,
  TContext = unknown,
>(options?: {
  mutation?: UseMutationOptions<
    Awaited<ReturnType<typeof addComment>>,
    TError,
    { projectId: string; stopId: string; data: AddCommentCommand },
    TContext
  >;
  axios?: AxiosRequestConfig;
}): UseMutationOptions<
  Awaited<ReturnType<typeof addComment>>,
  TError,
  { projectId: string; stopId: string; data: AddCommentCommand },
  TContext
> => {
  const mutationKey = ["addComment"];
  const { mutation: mutationOptions, axios: axiosOptions } = options
    ? options.mutation &&
      "mutationKey" in options.mutation &&
      options.mutation.mutationKey
      ? options
      : { ...options, mutation: { ...options.mutation, mutationKey } }
    : { mutation: { mutationKey }, axios: undefined };

  const mutationFn: MutationFunction<
    Awaited<ReturnType<typeof addComment>>,
    { projectId: string; stopId: string; data: AddCommentCommand }
  > = (props) => {
    const { projectId, stopId, data } = props ?? {};

    return addComment(projectId, stopId, data, axiosOptions);
  };

  return { mutationFn, ...mutationOptions };
};

export type AddCommentMutationResult = NonNullable<
  Awaited<ReturnType<typeof addComment>>
>;
export type AddCommentMutationBody = AddCommentCommand;
export type AddCommentMutationError = AxiosError<unknown>;

export const useAddComment = <TError = AxiosError<unknown>, TContext = unknown>(
  options?: {
    mutation?: UseMutationOptions<
      Awaited<ReturnType<typeof addComment>>,
      TError,
      { projectId: string; stopId: string; data: AddCommentCommand },
      TContext
    >;
    axios?: AxiosRequestConfig;
  },
  queryClient?: QueryClient,
): UseMutationResult<
  Awaited<ReturnType<typeof addComment>>,
  TError,
  { projectId: string; stopId: string; data: AddCommentCommand },
  TContext
> => {
  const mutationOptions = getAddCommentMutationOptions(options);

  return useMutation(mutationOptions, queryClient);
};

export const getUnassignedStops = (
  projectId: string,
  options?: AxiosRequestConfig,
): Promise<AxiosResponse<StopDto[]>> => {
  return axios.default.get(
    `https://localhost:7520/projects/${projectId}/stops/unassigned`,
    options,
  );
};

export const getGetUnassignedStopsQueryKey = (projectId: string) => {
  return [
    `https://localhost:7520/projects/${projectId}/stops/unassigned`,
  ] as const;
};

export const getGetUnassignedStopsQueryOptions = <
  TData = Awaited<ReturnType<typeof getUnassignedStops>>,
  TError = AxiosError<unknown>,
>(
  projectId: string,
  options?: {
    query?: Partial<
      UseQueryOptions<
        Awaited<ReturnType<typeof getUnassignedStops>>,
        TError,
        TData
      >
    >;
    axios?: AxiosRequestConfig;
  },
) => {
  const { query: queryOptions, axios: axiosOptions } = options ?? {};

  const queryKey =
    queryOptions?.queryKey ?? getGetUnassignedStopsQueryKey(projectId);

  const queryFn: QueryFunction<
    Awaited<ReturnType<typeof getUnassignedStops>>
  > = ({ signal }) =>
    getUnassignedStops(projectId, { signal, ...axiosOptions });

  return {
    queryKey,
    queryFn,
    enabled: !!projectId,
    ...queryOptions,
  } as UseQueryOptions<
    Awaited<ReturnType<typeof getUnassignedStops>>,
    TError,
    TData
  > & { queryKey: DataTag<QueryKey, TData, TError> };
};

export type GetUnassignedStopsQueryResult = NonNullable<
  Awaited<ReturnType<typeof getUnassignedStops>>
>;
export type GetUnassignedStopsQueryError = AxiosError<unknown>;

export function useGetUnassignedStops<
  TData = Awaited<ReturnType<typeof getUnassignedStops>>,
  TError = AxiosError<unknown>,
>(
  projectId: string,
  options: {
    query: Partial<
      UseQueryOptions<
        Awaited<ReturnType<typeof getUnassignedStops>>,
        TError,
        TData
      >
    > &
      Pick<
        DefinedInitialDataOptions<
          Awaited<ReturnType<typeof getUnassignedStops>>,
          TError,
          Awaited<ReturnType<typeof getUnassignedStops>>
        >,
        "initialData"
      >;
    axios?: AxiosRequestConfig;
  },
  queryClient?: QueryClient,
): DefinedUseQueryResult<TData, TError> & {
  queryKey: DataTag<QueryKey, TData, TError>;
};
export function useGetUnassignedStops<
  TData = Awaited<ReturnType<typeof getUnassignedStops>>,
  TError = AxiosError<unknown>,
>(
  projectId: string,
  options?: {
    query?: Partial<
      UseQueryOptions<
        Awaited<ReturnType<typeof getUnassignedStops>>,
        TError,
        TData
      >
    > &
      Pick<
        UndefinedInitialDataOptions<
          Awaited<ReturnType<typeof getUnassignedStops>>,
          TError,
          Awaited<ReturnType<typeof getUnassignedStops>>
        >,
        "initialData"
      >;
    axios?: AxiosRequestConfig;
  },
  queryClient?: QueryClient,
): UseQueryResult<TData, TError> & {
  queryKey: DataTag<QueryKey, TData, TError>;
};
export function useGetUnassignedStops<
  TData = Awaited<ReturnType<typeof getUnassignedStops>>,
  TError = AxiosError<unknown>,
>(
  projectId: string,
  options?: {
    query?: Partial<
      UseQueryOptions<
        Awaited<ReturnType<typeof getUnassignedStops>>,
        TError,
        TData
      >
    >;
    axios?: AxiosRequestConfig;
  },
  queryClient?: QueryClient,
): UseQueryResult<TData, TError> & {
  queryKey: DataTag<QueryKey, TData, TError>;
};

export function useGetUnassignedStops<
  TData = Awaited<ReturnType<typeof getUnassignedStops>>,
  TError = AxiosError<unknown>,
>(
  projectId: string,
  options?: {
    query?: Partial<
      UseQueryOptions<
        Awaited<ReturnType<typeof getUnassignedStops>>,
        TError,
        TData
      >
    >;
    axios?: AxiosRequestConfig;
  },
  queryClient?: QueryClient,
): UseQueryResult<TData, TError> & {
  queryKey: DataTag<QueryKey, TData, TError>;
} {
  const queryOptions = getGetUnassignedStopsQueryOptions(projectId, options);

  const query = useQuery(queryOptions, queryClient) as UseQueryResult<
    TData,
    TError
  > & { queryKey: DataTag<QueryKey, TData, TError> };

  query.queryKey = queryOptions.queryKey;

  return query;
}

export const createTeam = (
  projectId: string,
  createTeamCommand: CreateTeamCommand,
  options?: AxiosRequestConfig,
): Promise<AxiosResponse<void>> => {
  return axios.default.post(
    `https://localhost:7520/projects/${projectId}/teams`,
    createTeamCommand,
    options,
  );
};

export const getCreateTeamMutationOptions = <
  TError = AxiosError<ProblemDetails>,
  TContext = unknown,
>(options?: {
  mutation?: UseMutationOptions<
    Awaited<ReturnType<typeof createTeam>>,
    TError,
    { projectId: string; data: CreateTeamCommand },
    TContext
  >;
  axios?: AxiosRequestConfig;
}): UseMutationOptions<
  Awaited<ReturnType<typeof createTeam>>,
  TError,
  { projectId: string; data: CreateTeamCommand },
  TContext
> => {
  const mutationKey = ["createTeam"];
  const { mutation: mutationOptions, axios: axiosOptions } = options
    ? options.mutation &&
      "mutationKey" in options.mutation &&
      options.mutation.mutationKey
      ? options
      : { ...options, mutation: { ...options.mutation, mutationKey } }
    : { mutation: { mutationKey }, axios: undefined };

  const mutationFn: MutationFunction<
    Awaited<ReturnType<typeof createTeam>>,
    { projectId: string; data: CreateTeamCommand }
  > = (props) => {
    const { projectId, data } = props ?? {};

    return createTeam(projectId, data, axiosOptions);
  };

  return { mutationFn, ...mutationOptions };
};

export type CreateTeamMutationResult = NonNullable<
  Awaited<ReturnType<typeof createTeam>>
>;
export type CreateTeamMutationBody = CreateTeamCommand;
export type CreateTeamMutationError = AxiosError<ProblemDetails>;

export const useCreateTeam = <
  TError = AxiosError<ProblemDetails>,
  TContext = unknown,
>(
  options?: {
    mutation?: UseMutationOptions<
      Awaited<ReturnType<typeof createTeam>>,
      TError,
      { projectId: string; data: CreateTeamCommand },
      TContext
    >;
    axios?: AxiosRequestConfig;
  },
  queryClient?: QueryClient,
): UseMutationResult<
  Awaited<ReturnType<typeof createTeam>>,
  TError,
  { projectId: string; data: CreateTeamCommand },
  TContext
> => {
  const mutationOptions = getCreateTeamMutationOptions(options);

  return useMutation(mutationOptions, queryClient);
};

export const getAllTeams = (
  projectId: string,
  options?: AxiosRequestConfig,
): Promise<AxiosResponse<ListTeamDto[]>> => {
  return axios.default.get(
    `https://localhost:7520/projects/${projectId}/teams`,
    options,
  );
};

export const getGetAllTeamsQueryKey = (projectId: string) => {
  return [`https://localhost:7520/projects/${projectId}/teams`] as const;
};

export const getGetAllTeamsQueryOptions = <
  TData = Awaited<ReturnType<typeof getAllTeams>>,
  TError = AxiosError<unknown>,
>(
  projectId: string,
  options?: {
    query?: Partial<
      UseQueryOptions<Awaited<ReturnType<typeof getAllTeams>>, TError, TData>
    >;
    axios?: AxiosRequestConfig;
  },
) => {
  const { query: queryOptions, axios: axiosOptions } = options ?? {};

  const queryKey = queryOptions?.queryKey ?? getGetAllTeamsQueryKey(projectId);

  const queryFn: QueryFunction<Awaited<ReturnType<typeof getAllTeams>>> = ({
    signal,
  }) => getAllTeams(projectId, { signal, ...axiosOptions });

  return {
    queryKey,
    queryFn,
    enabled: !!projectId,
    ...queryOptions,
  } as UseQueryOptions<
    Awaited<ReturnType<typeof getAllTeams>>,
    TError,
    TData
  > & { queryKey: DataTag<QueryKey, TData, TError> };
};

export type GetAllTeamsQueryResult = NonNullable<
  Awaited<ReturnType<typeof getAllTeams>>
>;
export type GetAllTeamsQueryError = AxiosError<unknown>;

export function useGetAllTeams<
  TData = Awaited<ReturnType<typeof getAllTeams>>,
  TError = AxiosError<unknown>,
>(
  projectId: string,
  options: {
    query: Partial<
      UseQueryOptions<Awaited<ReturnType<typeof getAllTeams>>, TError, TData>
    > &
      Pick<
        DefinedInitialDataOptions<
          Awaited<ReturnType<typeof getAllTeams>>,
          TError,
          Awaited<ReturnType<typeof getAllTeams>>
        >,
        "initialData"
      >;
    axios?: AxiosRequestConfig;
  },
  queryClient?: QueryClient,
): DefinedUseQueryResult<TData, TError> & {
  queryKey: DataTag<QueryKey, TData, TError>;
};
export function useGetAllTeams<
  TData = Awaited<ReturnType<typeof getAllTeams>>,
  TError = AxiosError<unknown>,
>(
  projectId: string,
  options?: {
    query?: Partial<
      UseQueryOptions<Awaited<ReturnType<typeof getAllTeams>>, TError, TData>
    > &
      Pick<
        UndefinedInitialDataOptions<
          Awaited<ReturnType<typeof getAllTeams>>,
          TError,
          Awaited<ReturnType<typeof getAllTeams>>
        >,
        "initialData"
      >;
    axios?: AxiosRequestConfig;
  },
  queryClient?: QueryClient,
): UseQueryResult<TData, TError> & {
  queryKey: DataTag<QueryKey, TData, TError>;
};
export function useGetAllTeams<
  TData = Awaited<ReturnType<typeof getAllTeams>>,
  TError = AxiosError<unknown>,
>(
  projectId: string,
  options?: {
    query?: Partial<
      UseQueryOptions<Awaited<ReturnType<typeof getAllTeams>>, TError, TData>
    >;
    axios?: AxiosRequestConfig;
  },
  queryClient?: QueryClient,
): UseQueryResult<TData, TError> & {
  queryKey: DataTag<QueryKey, TData, TError>;
};

export function useGetAllTeams<
  TData = Awaited<ReturnType<typeof getAllTeams>>,
  TError = AxiosError<unknown>,
>(
  projectId: string,
  options?: {
    query?: Partial<
      UseQueryOptions<Awaited<ReturnType<typeof getAllTeams>>, TError, TData>
    >;
    axios?: AxiosRequestConfig;
  },
  queryClient?: QueryClient,
): UseQueryResult<TData, TError> & {
  queryKey: DataTag<QueryKey, TData, TError>;
} {
  const queryOptions = getGetAllTeamsQueryOptions(projectId, options);

  const query = useQuery(queryOptions, queryClient) as UseQueryResult<
    TData,
    TError
  > & { queryKey: DataTag<QueryKey, TData, TError> };

  query.queryKey = queryOptions.queryKey;

  return query;
}

export const updateTeamName = (
  projectId: string,
  teamId: string,
  updateTeamNameCommand: UpdateTeamNameCommand,
  options?: AxiosRequestConfig,
): Promise<AxiosResponse<void>> => {
  return axios.default.put(
    `https://localhost:7520/projects/${projectId}/teams/${teamId}/name`,
    updateTeamNameCommand,
    options,
  );
};

export const getUpdateTeamNameMutationOptions = <
  TError = AxiosError<ProblemDetails>,
  TContext = unknown,
>(options?: {
  mutation?: UseMutationOptions<
    Awaited<ReturnType<typeof updateTeamName>>,
    TError,
    { projectId: string; teamId: string; data: UpdateTeamNameCommand },
    TContext
  >;
  axios?: AxiosRequestConfig;
}): UseMutationOptions<
  Awaited<ReturnType<typeof updateTeamName>>,
  TError,
  { projectId: string; teamId: string; data: UpdateTeamNameCommand },
  TContext
> => {
  const mutationKey = ["updateTeamName"];
  const { mutation: mutationOptions, axios: axiosOptions } = options
    ? options.mutation &&
      "mutationKey" in options.mutation &&
      options.mutation.mutationKey
      ? options
      : { ...options, mutation: { ...options.mutation, mutationKey } }
    : { mutation: { mutationKey }, axios: undefined };

  const mutationFn: MutationFunction<
    Awaited<ReturnType<typeof updateTeamName>>,
    { projectId: string; teamId: string; data: UpdateTeamNameCommand }
  > = (props) => {
    const { projectId, teamId, data } = props ?? {};

    return updateTeamName(projectId, teamId, data, axiosOptions);
  };

  return { mutationFn, ...mutationOptions };
};

export type UpdateTeamNameMutationResult = NonNullable<
  Awaited<ReturnType<typeof updateTeamName>>
>;
export type UpdateTeamNameMutationBody = UpdateTeamNameCommand;
export type UpdateTeamNameMutationError = AxiosError<ProblemDetails>;

export const useUpdateTeamName = <
  TError = AxiosError<ProblemDetails>,
  TContext = unknown,
>(
  options?: {
    mutation?: UseMutationOptions<
      Awaited<ReturnType<typeof updateTeamName>>,
      TError,
      { projectId: string; teamId: string; data: UpdateTeamNameCommand },
      TContext
    >;
    axios?: AxiosRequestConfig;
  },
  queryClient?: QueryClient,
): UseMutationResult<
  Awaited<ReturnType<typeof updateTeamName>>,
  TError,
  { projectId: string; teamId: string; data: UpdateTeamNameCommand },
  TContext
> => {
  const mutationOptions = getUpdateTeamNameMutationOptions(options);

  return useMutation(mutationOptions, queryClient);
};

export const updateTeamLead = (
  projectId: string,
  teamId: string,
  updateTeamLeadCommand: UpdateTeamLeadCommand,
  options?: AxiosRequestConfig,
): Promise<AxiosResponse<void>> => {
  return axios.default.put(
    `https://localhost:7520/projects/${projectId}/teams/${teamId}/teamLead`,
    updateTeamLeadCommand,
    options,
  );
};

export const getUpdateTeamLeadMutationOptions = <
  TError = AxiosError<ProblemDetails>,
  TContext = unknown,
>(options?: {
  mutation?: UseMutationOptions<
    Awaited<ReturnType<typeof updateTeamLead>>,
    TError,
    { projectId: string; teamId: string; data: UpdateTeamLeadCommand },
    TContext
  >;
  axios?: AxiosRequestConfig;
}): UseMutationOptions<
  Awaited<ReturnType<typeof updateTeamLead>>,
  TError,
  { projectId: string; teamId: string; data: UpdateTeamLeadCommand },
  TContext
> => {
  const mutationKey = ["updateTeamLead"];
  const { mutation: mutationOptions, axios: axiosOptions } = options
    ? options.mutation &&
      "mutationKey" in options.mutation &&
      options.mutation.mutationKey
      ? options
      : { ...options, mutation: { ...options.mutation, mutationKey } }
    : { mutation: { mutationKey }, axios: undefined };

  const mutationFn: MutationFunction<
    Awaited<ReturnType<typeof updateTeamLead>>,
    { projectId: string; teamId: string; data: UpdateTeamLeadCommand }
  > = (props) => {
    const { projectId, teamId, data } = props ?? {};

    return updateTeamLead(projectId, teamId, data, axiosOptions);
  };

  return { mutationFn, ...mutationOptions };
};

export type UpdateTeamLeadMutationResult = NonNullable<
  Awaited<ReturnType<typeof updateTeamLead>>
>;
export type UpdateTeamLeadMutationBody = UpdateTeamLeadCommand;
export type UpdateTeamLeadMutationError = AxiosError<ProblemDetails>;

export const useUpdateTeamLead = <
  TError = AxiosError<ProblemDetails>,
  TContext = unknown,
>(
  options?: {
    mutation?: UseMutationOptions<
      Awaited<ReturnType<typeof updateTeamLead>>,
      TError,
      { projectId: string; teamId: string; data: UpdateTeamLeadCommand },
      TContext
    >;
    axios?: AxiosRequestConfig;
  },
  queryClient?: QueryClient,
): UseMutationResult<
  Awaited<ReturnType<typeof updateTeamLead>>,
  TError,
  { projectId: string; teamId: string; data: UpdateTeamLeadCommand },
  TContext
> => {
  const mutationOptions = getUpdateTeamLeadMutationOptions(options);

  return useMutation(mutationOptions, queryClient);
};

export const updateTeamPhone = (
  projectId: string,
  teamId: string,
  updateTeamPhoneCommand: UpdateTeamPhoneCommand,
  options?: AxiosRequestConfig,
): Promise<AxiosResponse<void>> => {
  return axios.default.put(
    `https://localhost:7520/projects/${projectId}/teams/${teamId}/phone`,
    updateTeamPhoneCommand,
    options,
  );
};

export const getUpdateTeamPhoneMutationOptions = <
  TError = AxiosError<ProblemDetails>,
  TContext = unknown,
>(options?: {
  mutation?: UseMutationOptions<
    Awaited<ReturnType<typeof updateTeamPhone>>,
    TError,
    { projectId: string; teamId: string; data: UpdateTeamPhoneCommand },
    TContext
  >;
  axios?: AxiosRequestConfig;
}): UseMutationOptions<
  Awaited<ReturnType<typeof updateTeamPhone>>,
  TError,
  { projectId: string; teamId: string; data: UpdateTeamPhoneCommand },
  TContext
> => {
  const mutationKey = ["updateTeamPhone"];
  const { mutation: mutationOptions, axios: axiosOptions } = options
    ? options.mutation &&
      "mutationKey" in options.mutation &&
      options.mutation.mutationKey
      ? options
      : { ...options, mutation: { ...options.mutation, mutationKey } }
    : { mutation: { mutationKey }, axios: undefined };

  const mutationFn: MutationFunction<
    Awaited<ReturnType<typeof updateTeamPhone>>,
    { projectId: string; teamId: string; data: UpdateTeamPhoneCommand }
  > = (props) => {
    const { projectId, teamId, data } = props ?? {};

    return updateTeamPhone(projectId, teamId, data, axiosOptions);
  };

  return { mutationFn, ...mutationOptions };
};

export type UpdateTeamPhoneMutationResult = NonNullable<
  Awaited<ReturnType<typeof updateTeamPhone>>
>;
export type UpdateTeamPhoneMutationBody = UpdateTeamPhoneCommand;
export type UpdateTeamPhoneMutationError = AxiosError<ProblemDetails>;

export const useUpdateTeamPhone = <
  TError = AxiosError<ProblemDetails>,
  TContext = unknown,
>(
  options?: {
    mutation?: UseMutationOptions<
      Awaited<ReturnType<typeof updateTeamPhone>>,
      TError,
      { projectId: string; teamId: string; data: UpdateTeamPhoneCommand },
      TContext
    >;
    axios?: AxiosRequestConfig;
  },
  queryClient?: QueryClient,
): UseMutationResult<
  Awaited<ReturnType<typeof updateTeamPhone>>,
  TError,
  { projectId: string; teamId: string; data: UpdateTeamPhoneCommand },
  TContext
> => {
  const mutationOptions = getUpdateTeamPhoneMutationOptions(options);

  return useMutation(mutationOptions, queryClient);
};

export const updateTeamTrailerType = (
  projectId: string,
  teamId: string,
  updateTeamTrailerTypeCommand: UpdateTeamTrailerTypeCommand,
  options?: AxiosRequestConfig,
): Promise<AxiosResponse<void>> => {
  return axios.default.put(
    `https://localhost:7520/projects/${projectId}/teams/${teamId}/trailerType`,
    updateTeamTrailerTypeCommand,
    options,
  );
};

export const getUpdateTeamTrailerTypeMutationOptions = <
  TError = AxiosError<ProblemDetails>,
  TContext = unknown,
>(options?: {
  mutation?: UseMutationOptions<
    Awaited<ReturnType<typeof updateTeamTrailerType>>,
    TError,
    { projectId: string; teamId: string; data: UpdateTeamTrailerTypeCommand },
    TContext
  >;
  axios?: AxiosRequestConfig;
}): UseMutationOptions<
  Awaited<ReturnType<typeof updateTeamTrailerType>>,
  TError,
  { projectId: string; teamId: string; data: UpdateTeamTrailerTypeCommand },
  TContext
> => {
  const mutationKey = ["updateTeamTrailerType"];
  const { mutation: mutationOptions, axios: axiosOptions } = options
    ? options.mutation &&
      "mutationKey" in options.mutation &&
      options.mutation.mutationKey
      ? options
      : { ...options, mutation: { ...options.mutation, mutationKey } }
    : { mutation: { mutationKey }, axios: undefined };

  const mutationFn: MutationFunction<
    Awaited<ReturnType<typeof updateTeamTrailerType>>,
    { projectId: string; teamId: string; data: UpdateTeamTrailerTypeCommand }
  > = (props) => {
    const { projectId, teamId, data } = props ?? {};

    return updateTeamTrailerType(projectId, teamId, data, axiosOptions);
  };

  return { mutationFn, ...mutationOptions };
};

export type UpdateTeamTrailerTypeMutationResult = NonNullable<
  Awaited<ReturnType<typeof updateTeamTrailerType>>
>;
export type UpdateTeamTrailerTypeMutationBody = UpdateTeamTrailerTypeCommand;
export type UpdateTeamTrailerTypeMutationError = AxiosError<ProblemDetails>;

export const useUpdateTeamTrailerType = <
  TError = AxiosError<ProblemDetails>,
  TContext = unknown,
>(
  options?: {
    mutation?: UseMutationOptions<
      Awaited<ReturnType<typeof updateTeamTrailerType>>,
      TError,
      { projectId: string; teamId: string; data: UpdateTeamTrailerTypeCommand },
      TContext
    >;
    axios?: AxiosRequestConfig;
  },
  queryClient?: QueryClient,
): UseMutationResult<
  Awaited<ReturnType<typeof updateTeamTrailerType>>,
  TError,
  { projectId: string; teamId: string; data: UpdateTeamTrailerTypeCommand },
  TContext
> => {
  const mutationOptions = getUpdateTeamTrailerTypeMutationOptions(options);

  return useMutation(mutationOptions, queryClient);
};

export const addTeamMember = (
  projectId: string,
  teamId: string,
  addTeamMemberCommand: AddTeamMemberCommand,
  options?: AxiosRequestConfig,
): Promise<AxiosResponse<void>> => {
  return axios.default.put(
    `https://localhost:7520/projects/${projectId}/teams/${teamId}/members`,
    addTeamMemberCommand,
    options,
  );
};

export const getAddTeamMemberMutationOptions = <
  TError = AxiosError<ProblemDetails>,
  TContext = unknown,
>(options?: {
  mutation?: UseMutationOptions<
    Awaited<ReturnType<typeof addTeamMember>>,
    TError,
    { projectId: string; teamId: string; data: AddTeamMemberCommand },
    TContext
  >;
  axios?: AxiosRequestConfig;
}): UseMutationOptions<
  Awaited<ReturnType<typeof addTeamMember>>,
  TError,
  { projectId: string; teamId: string; data: AddTeamMemberCommand },
  TContext
> => {
  const mutationKey = ["addTeamMember"];
  const { mutation: mutationOptions, axios: axiosOptions } = options
    ? options.mutation &&
      "mutationKey" in options.mutation &&
      options.mutation.mutationKey
      ? options
      : { ...options, mutation: { ...options.mutation, mutationKey } }
    : { mutation: { mutationKey }, axios: undefined };

  const mutationFn: MutationFunction<
    Awaited<ReturnType<typeof addTeamMember>>,
    { projectId: string; teamId: string; data: AddTeamMemberCommand }
  > = (props) => {
    const { projectId, teamId, data } = props ?? {};

    return addTeamMember(projectId, teamId, data, axiosOptions);
  };

  return { mutationFn, ...mutationOptions };
};

export type AddTeamMemberMutationResult = NonNullable<
  Awaited<ReturnType<typeof addTeamMember>>
>;
export type AddTeamMemberMutationBody = AddTeamMemberCommand;
export type AddTeamMemberMutationError = AxiosError<ProblemDetails>;

export const useAddTeamMember = <
  TError = AxiosError<ProblemDetails>,
  TContext = unknown,
>(
  options?: {
    mutation?: UseMutationOptions<
      Awaited<ReturnType<typeof addTeamMember>>,
      TError,
      { projectId: string; teamId: string; data: AddTeamMemberCommand },
      TContext
    >;
    axios?: AxiosRequestConfig;
  },
  queryClient?: QueryClient,
): UseMutationResult<
  Awaited<ReturnType<typeof addTeamMember>>,
  TError,
  { projectId: string; teamId: string; data: AddTeamMemberCommand },
  TContext
> => {
  const mutationOptions = getAddTeamMemberMutationOptions(options);

  return useMutation(mutationOptions, queryClient);
};

export const removeTeamMember = (
  projectId: string,
  teamId: string,
  name: string,
  options?: AxiosRequestConfig,
): Promise<AxiosResponse<void>> => {
  return axios.default.delete(
    `https://localhost:7520/projects/${projectId}/teams/${teamId}/members/${name}`,
    options,
  );
};

export const getRemoveTeamMemberMutationOptions = <
  TError = AxiosError<ProblemDetails>,
  TContext = unknown,
>(options?: {
  mutation?: UseMutationOptions<
    Awaited<ReturnType<typeof removeTeamMember>>,
    TError,
    { projectId: string; teamId: string; name: string },
    TContext
  >;
  axios?: AxiosRequestConfig;
}): UseMutationOptions<
  Awaited<ReturnType<typeof removeTeamMember>>,
  TError,
  { projectId: string; teamId: string; name: string },
  TContext
> => {
  const mutationKey = ["removeTeamMember"];
  const { mutation: mutationOptions, axios: axiosOptions } = options
    ? options.mutation &&
      "mutationKey" in options.mutation &&
      options.mutation.mutationKey
      ? options
      : { ...options, mutation: { ...options.mutation, mutationKey } }
    : { mutation: { mutationKey }, axios: undefined };

  const mutationFn: MutationFunction<
    Awaited<ReturnType<typeof removeTeamMember>>,
    { projectId: string; teamId: string; name: string }
  > = (props) => {
    const { projectId, teamId, name } = props ?? {};

    return removeTeamMember(projectId, teamId, name, axiosOptions);
  };

  return { mutationFn, ...mutationOptions };
};

export type RemoveTeamMemberMutationResult = NonNullable<
  Awaited<ReturnType<typeof removeTeamMember>>
>;

export type RemoveTeamMemberMutationError = AxiosError<ProblemDetails>;

export const useRemoveTeamMember = <
  TError = AxiosError<ProblemDetails>,
  TContext = unknown,
>(
  options?: {
    mutation?: UseMutationOptions<
      Awaited<ReturnType<typeof removeTeamMember>>,
      TError,
      { projectId: string; teamId: string; name: string },
      TContext
    >;
    axios?: AxiosRequestConfig;
  },
  queryClient?: QueryClient,
): UseMutationResult<
  Awaited<ReturnType<typeof removeTeamMember>>,
  TError,
  { projectId: string; teamId: string; name: string },
  TContext
> => {
  const mutationOptions = getRemoveTeamMemberMutationOptions(options);

  return useMutation(mutationOptions, queryClient);
};

export const getTeam = (
  projectId: string,
  teamId: string,
  options?: AxiosRequestConfig,
): Promise<AxiosResponse<TeamDto>> => {
  return axios.default.get(
    `https://localhost:7520/projects/${projectId}/teams/${teamId}`,
    options,
  );
};

export const getGetTeamQueryKey = (projectId: string, teamId: string) => {
  return [
    `https://localhost:7520/projects/${projectId}/teams/${teamId}`,
  ] as const;
};

export const getGetTeamQueryOptions = <
  TData = Awaited<ReturnType<typeof getTeam>>,
  TError = AxiosError<unknown>,
>(
  projectId: string,
  teamId: string,
  options?: {
    query?: Partial<
      UseQueryOptions<Awaited<ReturnType<typeof getTeam>>, TError, TData>
    >;
    axios?: AxiosRequestConfig;
  },
) => {
  const { query: queryOptions, axios: axiosOptions } = options ?? {};

  const queryKey =
    queryOptions?.queryKey ?? getGetTeamQueryKey(projectId, teamId);

  const queryFn: QueryFunction<Awaited<ReturnType<typeof getTeam>>> = ({
    signal,
  }) => getTeam(projectId, teamId, { signal, ...axiosOptions });

  return {
    queryKey,
    queryFn,
    enabled: !!(projectId && teamId),
    ...queryOptions,
  } as UseQueryOptions<Awaited<ReturnType<typeof getTeam>>, TError, TData> & {
    queryKey: DataTag<QueryKey, TData, TError>;
  };
};

export type GetTeamQueryResult = NonNullable<
  Awaited<ReturnType<typeof getTeam>>
>;
export type GetTeamQueryError = AxiosError<unknown>;

export function useGetTeam<
  TData = Awaited<ReturnType<typeof getTeam>>,
  TError = AxiosError<unknown>,
>(
  projectId: string,
  teamId: string,
  options: {
    query: Partial<
      UseQueryOptions<Awaited<ReturnType<typeof getTeam>>, TError, TData>
    > &
      Pick<
        DefinedInitialDataOptions<
          Awaited<ReturnType<typeof getTeam>>,
          TError,
          Awaited<ReturnType<typeof getTeam>>
        >,
        "initialData"
      >;
    axios?: AxiosRequestConfig;
  },
  queryClient?: QueryClient,
): DefinedUseQueryResult<TData, TError> & {
  queryKey: DataTag<QueryKey, TData, TError>;
};
export function useGetTeam<
  TData = Awaited<ReturnType<typeof getTeam>>,
  TError = AxiosError<unknown>,
>(
  projectId: string,
  teamId: string,
  options?: {
    query?: Partial<
      UseQueryOptions<Awaited<ReturnType<typeof getTeam>>, TError, TData>
    > &
      Pick<
        UndefinedInitialDataOptions<
          Awaited<ReturnType<typeof getTeam>>,
          TError,
          Awaited<ReturnType<typeof getTeam>>
        >,
        "initialData"
      >;
    axios?: AxiosRequestConfig;
  },
  queryClient?: QueryClient,
): UseQueryResult<TData, TError> & {
  queryKey: DataTag<QueryKey, TData, TError>;
};
export function useGetTeam<
  TData = Awaited<ReturnType<typeof getTeam>>,
  TError = AxiosError<unknown>,
>(
  projectId: string,
  teamId: string,
  options?: {
    query?: Partial<
      UseQueryOptions<Awaited<ReturnType<typeof getTeam>>, TError, TData>
    >;
    axios?: AxiosRequestConfig;
  },
  queryClient?: QueryClient,
): UseQueryResult<TData, TError> & {
  queryKey: DataTag<QueryKey, TData, TError>;
};

export function useGetTeam<
  TData = Awaited<ReturnType<typeof getTeam>>,
  TError = AxiosError<unknown>,
>(
  projectId: string,
  teamId: string,
  options?: {
    query?: Partial<
      UseQueryOptions<Awaited<ReturnType<typeof getTeam>>, TError, TData>
    >;
    axios?: AxiosRequestConfig;
  },
  queryClient?: QueryClient,
): UseQueryResult<TData, TError> & {
  queryKey: DataTag<QueryKey, TData, TError>;
} {
  const queryOptions = getGetTeamQueryOptions(projectId, teamId, options);

  const query = useQuery(queryOptions, queryClient) as UseQueryResult<
    TData,
    TError
  > & { queryKey: DataTag<QueryKey, TData, TError> };

  query.queryKey = queryOptions.queryKey;

  return query;
}
